// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vagrant_plugin_sdk

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// TerminalUIServiceClient is the client API for TerminalUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TerminalUIServiceClient interface {
	Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error)
	IsInteractive(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error)
}

type terminalUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalUIServiceClient(cc grpc.ClientConnInterface) TerminalUIServiceClient {
	return &terminalUIServiceClient{cc}
}

func (c *terminalUIServiceClient) Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/Output", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TerminalUIService_serviceDesc.Streams[0], "/hashicorp.vagrant.sdk.TerminalUIService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalUIServiceEventsClient{stream}
	return x, nil
}

type TerminalUIService_EventsClient interface {
	Send(*TerminalUI_Event) error
	Recv() (*TerminalUI_Response, error)
	grpc.ClientStream
}

type terminalUIServiceEventsClient struct {
	grpc.ClientStream
}

func (x *terminalUIServiceEventsClient) Send(m *TerminalUI_Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalUIServiceEventsClient) Recv() (*TerminalUI_Response, error) {
	m := new(TerminalUI_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalUIServiceClient) IsInteractive(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error) {
	out := new(TerminalUI_IsInteractiveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalUIServiceServer is the server API for TerminalUIService service.
// All implementations must embed UnimplementedTerminalUIServiceServer
// for forward compatibility
type TerminalUIServiceServer interface {
	Output(context.Context, *TerminalUI_OutputRequest) (*empty.Empty, error)
	Events(TerminalUIService_EventsServer) error
	IsInteractive(context.Context, *empty.Empty) (*TerminalUI_IsInteractiveResponse, error)
	mustEmbedUnimplementedTerminalUIServiceServer()
}

// UnimplementedTerminalUIServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTerminalUIServiceServer struct {
}

func (UnimplementedTerminalUIServiceServer) Output(context.Context, *TerminalUI_OutputRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedTerminalUIServiceServer) Events(TerminalUIService_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsInteractive(context.Context, *empty.Empty) (*TerminalUI_IsInteractiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInteractive not implemented")
}
func (UnimplementedTerminalUIServiceServer) mustEmbedUnimplementedTerminalUIServiceServer() {}

// UnsafeTerminalUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalUIServiceServer will
// result in compilation errors.
type UnsafeTerminalUIServiceServer interface {
	mustEmbedUnimplementedTerminalUIServiceServer()
}

func RegisterTerminalUIServiceServer(s grpc.ServiceRegistrar, srv TerminalUIServiceServer) {
	s.RegisterService(&_TerminalUIService_serviceDesc, srv)
}

func _TerminalUIService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminalUI_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/Output",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).Output(ctx, req.(*TerminalUI_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalUIServiceServer).Events(&terminalUIServiceEventsServer{stream})
}

type TerminalUIService_EventsServer interface {
	Send(*TerminalUI_Response) error
	Recv() (*TerminalUI_Event, error)
	grpc.ServerStream
}

type terminalUIServiceEventsServer struct {
	grpc.ServerStream
}

func (x *terminalUIServiceEventsServer) Send(m *TerminalUI_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalUIServiceEventsServer) Recv() (*TerminalUI_Event, error) {
	m := new(TerminalUI_Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TerminalUIService_IsInteractive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TerminalUIService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TerminalUIService",
	HandlerType: (*TerminalUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _TerminalUIService_Output_Handler,
		},
		{
			MethodName: "IsInteractive",
			Handler:    _TerminalUIService_IsInteractive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _TerminalUIService_Events_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// MapperClient is the client API for Mapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapperClient interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error)
}

type mapperClient struct {
	cc grpc.ClientConnInterface
}

func NewMapperClient(cc grpc.ClientConnInterface) MapperClient {
	return &mapperClient{cc}
}

func (c *mapperClient) ListMappers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error) {
	out := new(Map_ListResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/ListMappers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapperClient) Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error) {
	out := new(Map_Response)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/Map", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapperServer is the server API for Mapper service.
// All implementations must embed UnimplementedMapperServer
// for forward compatibility
type MapperServer interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(context.Context, *empty.Empty) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(context.Context, *Map_Request) (*Map_Response, error)
	mustEmbedUnimplementedMapperServer()
}

// UnimplementedMapperServer must be embedded to have forward compatible implementations.
type UnimplementedMapperServer struct {
}

func (UnimplementedMapperServer) ListMappers(context.Context, *empty.Empty) (*Map_ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappers not implemented")
}
func (UnimplementedMapperServer) Map(context.Context, *Map_Request) (*Map_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Map not implemented")
}
func (UnimplementedMapperServer) mustEmbedUnimplementedMapperServer() {}

// UnsafeMapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapperServer will
// result in compilation errors.
type UnsafeMapperServer interface {
	mustEmbedUnimplementedMapperServer()
}

func RegisterMapperServer(s grpc.ServiceRegistrar, srv MapperServer) {
	s.RegisterService(&_Mapper_serviceDesc, srv)
}

func _Mapper_ListMappers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).ListMappers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/ListMappers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).ListMappers(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mapper_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Map_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/Map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).Map(ctx, req.(*Map_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Mapper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.Mapper",
	HandlerType: (*MapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMappers",
			Handler:    _Mapper_ListMappers_Handler,
		},
		{
			MethodName: "Map",
			Handler:    _Mapper_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProviderServiceClient is the client API for ProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProviderServiceClient interface {
	// rpc Usable(google.protobuf.Empty) returns (Provider.UsableResp);
	// rpc Installed(google.protobuf.Empty) returns (Provider.InstalledResp);
	Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error)
	UsableSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error)
	InstalledSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*empty.Empty, error)
	InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ActionUp(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_ActionResp, error)
	ActionUpSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type providerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProviderServiceClient(cc grpc.ClientConnInterface) ProviderServiceClient {
	return &providerServiceClient{cc}
}

func (c *providerServiceClient) Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error) {
	out := new(Provider_UsableResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Usable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) UsableSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/UsableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error) {
	out := new(Provider_InstalledResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Installed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) InstalledSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/InitSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ActionUp(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_ActionResp, error) {
	out := new(Provider_ActionResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ActionUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ActionUpSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ActionUpSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProviderServiceServer is the server API for ProviderService service.
// All implementations must embed UnimplementedProviderServiceServer
// for forward compatibility
type ProviderServiceServer interface {
	// rpc Usable(google.protobuf.Empty) returns (Provider.UsableResp);
	// rpc Installed(google.protobuf.Empty) returns (Provider.InstalledResp);
	Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error)
	UsableSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error)
	InstalledSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Init(context.Context, *FuncSpec_Args) (*empty.Empty, error)
	InitSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	ActionUp(context.Context, *FuncSpec_Args) (*Provider_ActionResp, error)
	ActionUpSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	mustEmbedUnimplementedProviderServiceServer()
}

// UnimplementedProviderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProviderServiceServer struct {
}

func (UnimplementedProviderServiceServer) Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Usable not implemented")
}
func (UnimplementedProviderServiceServer) UsableSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsableSpec not implemented")
}
func (UnimplementedProviderServiceServer) Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Installed not implemented")
}
func (UnimplementedProviderServiceServer) InstalledSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstalledSpec not implemented")
}
func (UnimplementedProviderServiceServer) Init(context.Context, *FuncSpec_Args) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedProviderServiceServer) InitSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitSpec not implemented")
}
func (UnimplementedProviderServiceServer) ActionUp(context.Context, *FuncSpec_Args) (*Provider_ActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionUp not implemented")
}
func (UnimplementedProviderServiceServer) ActionUpSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionUpSpec not implemented")
}
func (UnimplementedProviderServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedProviderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProviderServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedProviderServiceServer) mustEmbedUnimplementedProviderServiceServer() {}

// UnsafeProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProviderServiceServer will
// result in compilation errors.
type UnsafeProviderServiceServer interface {
	mustEmbedUnimplementedProviderServiceServer()
}

func RegisterProviderServiceServer(s grpc.ServiceRegistrar, srv ProviderServiceServer) {
	s.RegisterService(&_ProviderService_serviceDesc, srv)
}

func _ProviderService_Usable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Usable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Usable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Usable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_UsableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).UsableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/UsableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).UsableSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Installed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Installed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Installed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Installed(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_InstalledSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Init(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_InitSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).InitSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/InitSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).InitSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ActionUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ActionUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ActionUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ActionUp(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ActionUpSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ActionUpSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ActionUpSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ActionUpSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProviderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProviderService",
	HandlerType: (*ProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Usable",
			Handler:    _ProviderService_Usable_Handler,
		},
		{
			MethodName: "UsableSpec",
			Handler:    _ProviderService_UsableSpec_Handler,
		},
		{
			MethodName: "Installed",
			Handler:    _ProviderService_Installed_Handler,
		},
		{
			MethodName: "InstalledSpec",
			Handler:    _ProviderService_InstalledSpec_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _ProviderService_Init_Handler,
		},
		{
			MethodName: "InitSpec",
			Handler:    _ProviderService_InitSpec_Handler,
		},
		{
			MethodName: "ActionUp",
			Handler:    _ProviderService_ActionUp_Handler,
		},
		{
			MethodName: "ActionUpSpec",
			Handler:    _ProviderService_ActionUpSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _ProviderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProviderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ProviderService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProvisionerServiceClient is the client API for ProvisionerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProvisionerServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type provisionerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProvisionerServiceClient(cc grpc.ClientConnInterface) ProvisionerServiceClient {
	return &provisionerServiceClient{cc}
}

func (c *provisionerServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProvisionerServiceServer is the server API for ProvisionerService service.
// All implementations must embed UnimplementedProvisionerServiceServer
// for forward compatibility
type ProvisionerServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	mustEmbedUnimplementedProvisionerServiceServer()
}

// UnimplementedProvisionerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProvisionerServiceServer struct {
}

func (UnimplementedProvisionerServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedProvisionerServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProvisionerServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedProvisionerServiceServer) mustEmbedUnimplementedProvisionerServiceServer() {}

// UnsafeProvisionerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProvisionerServiceServer will
// result in compilation errors.
type UnsafeProvisionerServiceServer interface {
	mustEmbedUnimplementedProvisionerServiceServer()
}

func RegisterProvisionerServiceServer(s grpc.ServiceRegistrar, srv ProvisionerServiceServer) {
	s.RegisterService(&_ProvisionerService_serviceDesc, srv)
}

func _ProvisionerService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProvisionerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProvisionerService",
	HandlerType: (*ProvisionerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ProvisionerService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProvisionerService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ProvisionerService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommandServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error)
	CommandInfoSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error) {
	out := new(Command_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfoSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error) {
	out := new(Command_CommandInfoResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
// All implementations must embed UnimplementedCommandServiceServer
// for forward compatibility
type CommandServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error)
	Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error)
	CommandInfoSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error)
	mustEmbedUnimplementedCommandServiceServer()
}

// UnimplementedCommandServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCommandServiceServer struct {
}

func (UnimplementedCommandServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommandServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommandServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommandServiceServer) ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommandServiceServer) Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfoSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfoSpec not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfo not implemented")
}
func (UnimplementedCommandServiceServer) mustEmbedUnimplementedCommandServiceServer() {}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	s.RegisterService(&_CommandService_serviceDesc, srv)
}

func _CommandService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteSpecReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, req.(*Command_ExecuteSpecReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Execute(ctx, req.(*Command_ExecuteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfoSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfo(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommandService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommandService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommandService_Documentation_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommandService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommandService_Execute_Handler,
		},
		{
			MethodName: "CommandInfoSpec",
			Handler:    _CommandService_CommandInfoSpec_Handler,
		},
		{
			MethodName: "CommandInfo",
			Handler:    _CommandService_CommandInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommunicatorServiceClient is the client API for CommunicatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommunicatorServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	MatchSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error)
	InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_InitResp, error)
	ReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	WaitForReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	DownloadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error)
	UploadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error)
	ExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	TestSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error)
	ResetSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ResetResp, error)
}

type communicatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommunicatorServiceClient(cc grpc.ClientConnInterface) CommunicatorServiceClient {
	return &communicatorServiceClient{cc}
}

func (c *communicatorServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) MatchSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error) {
	out := new(Communicator_MatchResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Match", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_InitResp, error) {
	out := new(Communicator_InitResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) DownloadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error) {
	out := new(Communicator_FileTransferResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Download", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) UploadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error) {
	out := new(Communicator_FileTransferResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) TestSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error) {
	out := new(Communicator_TestResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ResetSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ResetResp, error) {
	out := new(Communicator_ResetResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommunicatorServiceServer is the server API for CommunicatorService service.
// All implementations must embed UnimplementedCommunicatorServiceServer
// for forward compatibility
type CommunicatorServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	MatchSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error)
	InitSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Init(context.Context, *FuncSpec_Args) (*Communicator_InitResp, error)
	ReadySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	WaitForReadySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	DownloadSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Download(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error)
	UploadSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Upload(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error)
	ExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	TestSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error)
	ResetSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Reset(context.Context, *FuncSpec_Args) (*Communicator_ResetResp, error)
	mustEmbedUnimplementedCommunicatorServiceServer()
}

// UnimplementedCommunicatorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCommunicatorServiceServer struct {
}

func (UnimplementedCommunicatorServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommunicatorServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommunicatorServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommunicatorServiceServer) MatchSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Match not implemented")
}
func (UnimplementedCommunicatorServiceServer) InitSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Init(context.Context, *FuncSpec_Args) (*Communicator_InitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedCommunicatorServiceServer) ReadySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReadySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReady not implemented")
}
func (UnimplementedCommunicatorServiceServer) DownloadSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Download(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedCommunicatorServiceServer) UploadSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Upload(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedCommunicatorServiceServer) ExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecute not implemented")
}
func (UnimplementedCommunicatorServiceServer) TestSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedCommunicatorServiceServer) ResetSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Reset(context.Context, *FuncSpec_Args) (*Communicator_ResetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedCommunicatorServiceServer) mustEmbedUnimplementedCommunicatorServiceServer() {}

// UnsafeCommunicatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommunicatorServiceServer will
// result in compilation errors.
type UnsafeCommunicatorServiceServer interface {
	mustEmbedUnimplementedCommunicatorServiceServer()
}

func RegisterCommunicatorServiceServer(s grpc.ServiceRegistrar, srv CommunicatorServiceServer) {
	s.RegisterService(&_CommunicatorService_serviceDesc, srv)
}

func _CommunicatorService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_MatchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Match_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Match(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Match",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Match(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_InitSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Init(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Ready(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_DownloadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Download(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_UploadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Upload(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Execute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_TestSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Test(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ResetSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Reset(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommunicatorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommunicatorService",
	HandlerType: (*CommunicatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommunicatorService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommunicatorService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommunicatorService_Documentation_Handler,
		},
		{
			MethodName: "MatchSpec",
			Handler:    _CommunicatorService_MatchSpec_Handler,
		},
		{
			MethodName: "Match",
			Handler:    _CommunicatorService_Match_Handler,
		},
		{
			MethodName: "InitSpec",
			Handler:    _CommunicatorService_InitSpec_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _CommunicatorService_Init_Handler,
		},
		{
			MethodName: "ReadySpec",
			Handler:    _CommunicatorService_ReadySpec_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _CommunicatorService_Ready_Handler,
		},
		{
			MethodName: "WaitForReadySpec",
			Handler:    _CommunicatorService_WaitForReadySpec_Handler,
		},
		{
			MethodName: "WaitForReady",
			Handler:    _CommunicatorService_WaitForReady_Handler,
		},
		{
			MethodName: "DownloadSpec",
			Handler:    _CommunicatorService_DownloadSpec_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _CommunicatorService_Download_Handler,
		},
		{
			MethodName: "UploadSpec",
			Handler:    _CommunicatorService_UploadSpec_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _CommunicatorService_Upload_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommunicatorService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommunicatorService_Execute_Handler,
		},
		{
			MethodName: "PrivilegedExecuteSpec",
			Handler:    _CommunicatorService_PrivilegedExecuteSpec_Handler,
		},
		{
			MethodName: "PrivilegedExecute",
			Handler:    _CommunicatorService_PrivilegedExecute_Handler,
		},
		{
			MethodName: "TestSpec",
			Handler:    _CommunicatorService_TestSpec_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _CommunicatorService_Test_Handler,
		},
		{
			MethodName: "ResetSpec",
			Handler:    _CommunicatorService_ResetSpec_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _CommunicatorService_Reset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations must embed UnimplementedConfigServiceServer
// for forward compatibility
type ConfigServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	mustEmbedUnimplementedConfigServiceServer()
}

// UnimplementedConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedConfigServiceServer struct {
}

func (UnimplementedConfigServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedConfigServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedConfigServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedConfigServiceServer) mustEmbedUnimplementedConfigServiceServer() {}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	s.RegisterService(&_ConfigService_serviceDesc, srv)
}

func _ConfigService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ConfigService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ConfigService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ConfigService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// GuestServiceClient is the client API for GuestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Guest_DetectResp, error)
	DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*Guest_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*Guest_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
}

type guestServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestServiceClient(cc grpc.ClientConnInterface) GuestServiceClient {
	return &guestServiceClient{cc}
}

func (c *guestServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Guest_DetectResp, error) {
	out := new(Guest_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapability(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*Guest_Capability_CheckResp, error) {
	out := new(Guest_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapabilitySpec(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Capability(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*Guest_Capability_Resp, error) {
	out := new(Guest_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) CapabilitySpec(ctx context.Context, in *Guest_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestServiceServer is the server API for GuestService service.
// All implementations must embed UnimplementedGuestServiceServer
// for forward compatibility
type GuestServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Guest_DetectResp, error)
	DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	HasCapability(context.Context, *Guest_Capability_NamedRequest) (*Guest_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *Guest_Capability_NamedRequest) (*FuncSpec, error)
	Capability(context.Context, *Guest_Capability_NamedRequest) (*Guest_Capability_Resp, error)
	CapabilitySpec(context.Context, *Guest_Capability_NamedRequest) (*FuncSpec, error)
	mustEmbedUnimplementedGuestServiceServer()
}

// UnimplementedGuestServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGuestServiceServer struct {
}

func (UnimplementedGuestServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedGuestServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedGuestServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedGuestServiceServer) Detect(context.Context, *FuncSpec_Args) (*Guest_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedGuestServiceServer) DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedGuestServiceServer) HasCapability(context.Context, *Guest_Capability_NamedRequest) (*Guest_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedGuestServiceServer) HasCapabilitySpec(context.Context, *Guest_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) Capability(context.Context, *Guest_Capability_NamedRequest) (*Guest_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedGuestServiceServer) CapabilitySpec(context.Context, *Guest_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) mustEmbedUnimplementedGuestServiceServer() {}

// UnsafeGuestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestServiceServer will
// result in compilation errors.
type UnsafeGuestServiceServer interface {
	mustEmbedUnimplementedGuestServiceServer()
}

func RegisterGuestServiceServer(s grpc.ServiceRegistrar, srv GuestServiceServer) {
	s.RegisterService(&_GuestService_serviceDesc, srv)
}

func _GuestService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).DetectSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Guest_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapability(ctx, req.(*Guest_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Guest_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, req.(*Guest_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Guest_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Capability(ctx, req.(*Guest_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Guest_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, req.(*Guest_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuestService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.GuestService",
	HandlerType: (*GuestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _GuestService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _GuestService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _GuestService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _GuestService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _GuestService_DetectSpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _GuestService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _GuestService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _GuestService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _GuestService_CapabilitySpec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// HostServiceClient is the client API for HostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Host_DetectResp, error)
	DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*Host_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*Host_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
}

type hostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostServiceClient(cc grpc.ClientConnInterface) HostServiceClient {
	return &hostServiceClient{cc}
}

func (c *hostServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Host_DetectResp, error) {
	out := new(Host_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapability(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*Host_Capability_CheckResp, error) {
	out := new(Host_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Capability(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*Host_Capability_Resp, error) {
	out := new(Host_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) CapabilitySpec(ctx context.Context, in *Host_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostServiceServer is the server API for HostService service.
// All implementations must embed UnimplementedHostServiceServer
// for forward compatibility
type HostServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Host_DetectResp, error)
	DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	HasCapability(context.Context, *Host_Capability_NamedRequest) (*Host_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Capability(context.Context, *Host_Capability_NamedRequest) (*Host_Capability_Resp, error)
	CapabilitySpec(context.Context, *Host_Capability_NamedRequest) (*FuncSpec, error)
	mustEmbedUnimplementedHostServiceServer()
}

// UnimplementedHostServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHostServiceServer struct {
}

func (UnimplementedHostServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedHostServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedHostServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedHostServiceServer) Detect(context.Context, *FuncSpec_Args) (*Host_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedHostServiceServer) DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedHostServiceServer) HasCapability(context.Context, *Host_Capability_NamedRequest) (*Host_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedHostServiceServer) HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) Capability(context.Context, *Host_Capability_NamedRequest) (*Host_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedHostServiceServer) CapabilitySpec(context.Context, *Host_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) mustEmbedUnimplementedHostServiceServer() {}

// UnsafeHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostServiceServer will
// result in compilation errors.
type UnsafeHostServiceServer interface {
	mustEmbedUnimplementedHostServiceServer()
}

func RegisterHostServiceServer(s grpc.ServiceRegistrar, srv HostServiceServer) {
	s.RegisterService(&_HostService_serviceDesc, srv)
}

func _HostService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).DetectSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Host_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapability(ctx, req.(*Host_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Host_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Capability(ctx, req.(*Host_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Host_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).CapabilitySpec(ctx, req.(*Host_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HostService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.HostService",
	HandlerType: (*HostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _HostService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _HostService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _HostService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _HostService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _HostService_DetectSpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _HostService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _HostService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _HostService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _HostService_CapabilitySpec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// SyncedFolderServiceClient is the client API for SyncedFolderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncedFolderServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type syncedFolderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncedFolderServiceClient(cc grpc.ClientConnInterface) SyncedFolderServiceClient {
	return &syncedFolderServiceClient{cc}
}

func (c *syncedFolderServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncedFolderServiceServer is the server API for SyncedFolderService service.
// All implementations must embed UnimplementedSyncedFolderServiceServer
// for forward compatibility
type SyncedFolderServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	mustEmbedUnimplementedSyncedFolderServiceServer()
}

// UnimplementedSyncedFolderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSyncedFolderServiceServer struct {
}

func (UnimplementedSyncedFolderServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedSyncedFolderServiceServer) mustEmbedUnimplementedSyncedFolderServiceServer() {}

// UnsafeSyncedFolderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncedFolderServiceServer will
// result in compilation errors.
type UnsafeSyncedFolderServiceServer interface {
	mustEmbedUnimplementedSyncedFolderServiceServer()
}

func RegisterSyncedFolderServiceServer(s grpc.ServiceRegistrar, srv SyncedFolderServiceServer) {
	s.RegisterService(&_SyncedFolderService_serviceDesc, srv)
}

func _SyncedFolderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _SyncedFolderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.SyncedFolderService",
	HandlerType: (*SyncedFolderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _SyncedFolderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _SyncedFolderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _SyncedFolderService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// MachineServiceClient is the client API for MachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MachineServiceClient interface {
	// Getters and Setters
	SetName(ctx context.Context, in *Machine_SetNameRequest, opts ...grpc.CallOption) (*Machine_SetNameResponse, error)
	GetName(ctx context.Context, in *Machine_GetNameRequest, opts ...grpc.CallOption) (*Machine_GetNameResponse, error)
	SetID(ctx context.Context, in *Machine_SetIDRequest, opts ...grpc.CallOption) (*Machine_SetIDResponse, error)
	GetID(ctx context.Context, in *Machine_GetIDRequest, opts ...grpc.CallOption) (*Machine_GetIDResponse, error)
	SetState(ctx context.Context, in *Machine_SetStateRequest, opts ...grpc.CallOption) (*Machine_SetStateResponse, error)
	GetState(ctx context.Context, in *Machine_GetStateRequest, opts ...grpc.CallOption) (*Machine_GetStateResponse, error)
	SetUUID(ctx context.Context, in *Machine_SetUUIDRequest, opts ...grpc.CallOption) (*Machine_SetUUIDResponse, error)
	GetUUID(ctx context.Context, in *Machine_GetUUIDRequest, opts ...grpc.CallOption) (*Machine_GetUUIDResponse, error)
	Box(ctx context.Context, in *Machine_BoxRequest, opts ...grpc.CallOption) (*Machine_BoxResponse, error)
	Datadir(ctx context.Context, in *Machine_DatadirRequest, opts ...grpc.CallOption) (*Machine_DatadirResponse, error)
	LocalDataPath(ctx context.Context, in *Machine_LocalDataPathRequest, opts ...grpc.CallOption) (*Machine_LocalDataPathResponse, error)
	Provider(ctx context.Context, in *Machine_ProviderRequest, opts ...grpc.CallOption) (*Machine_ProviderResponse, error)
	VagrantfileName(ctx context.Context, in *Machine_VagrantfileNameRequest, opts ...grpc.CallOption) (*Machine_VagrantfileNameResponse, error)
	VagrantfilePath(ctx context.Context, in *Machine_VagrantfilePathRequest, opts ...grpc.CallOption) (*Machine_VagrantfilePathResponse, error)
	UpdatedAt(ctx context.Context, in *Machine_UpdatedAtRequest, opts ...grpc.CallOption) (*Machine_UpdatedAtResponse, error)
	UI(ctx context.Context, in *Machine_UIRequest, opts ...grpc.CallOption) (*Machine_UIResponse, error)
}

type machineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineServiceClient(cc grpc.ClientConnInterface) MachineServiceClient {
	return &machineServiceClient{cc}
}

func (c *machineServiceClient) SetName(ctx context.Context, in *Machine_SetNameRequest, opts ...grpc.CallOption) (*Machine_SetNameResponse, error) {
	out := new(Machine_SetNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/SetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetName(ctx context.Context, in *Machine_GetNameRequest, opts ...grpc.CallOption) (*Machine_GetNameResponse, error) {
	out := new(Machine_GetNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/GetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetID(ctx context.Context, in *Machine_SetIDRequest, opts ...grpc.CallOption) (*Machine_SetIDResponse, error) {
	out := new(Machine_SetIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/SetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetID(ctx context.Context, in *Machine_GetIDRequest, opts ...grpc.CallOption) (*Machine_GetIDResponse, error) {
	out := new(Machine_GetIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/GetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetState(ctx context.Context, in *Machine_SetStateRequest, opts ...grpc.CallOption) (*Machine_SetStateResponse, error) {
	out := new(Machine_SetStateResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/SetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetState(ctx context.Context, in *Machine_GetStateRequest, opts ...grpc.CallOption) (*Machine_GetStateResponse, error) {
	out := new(Machine_GetStateResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetUUID(ctx context.Context, in *Machine_SetUUIDRequest, opts ...grpc.CallOption) (*Machine_SetUUIDResponse, error) {
	out := new(Machine_SetUUIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/SetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetUUID(ctx context.Context, in *Machine_GetUUIDRequest, opts ...grpc.CallOption) (*Machine_GetUUIDResponse, error) {
	out := new(Machine_GetUUIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/GetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Box(ctx context.Context, in *Machine_BoxRequest, opts ...grpc.CallOption) (*Machine_BoxResponse, error) {
	out := new(Machine_BoxResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/Box", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Datadir(ctx context.Context, in *Machine_DatadirRequest, opts ...grpc.CallOption) (*Machine_DatadirResponse, error) {
	out := new(Machine_DatadirResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/Datadir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) LocalDataPath(ctx context.Context, in *Machine_LocalDataPathRequest, opts ...grpc.CallOption) (*Machine_LocalDataPathResponse, error) {
	out := new(Machine_LocalDataPathResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/LocalDataPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Provider(ctx context.Context, in *Machine_ProviderRequest, opts ...grpc.CallOption) (*Machine_ProviderResponse, error) {
	out := new(Machine_ProviderResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) VagrantfileName(ctx context.Context, in *Machine_VagrantfileNameRequest, opts ...grpc.CallOption) (*Machine_VagrantfileNameResponse, error) {
	out := new(Machine_VagrantfileNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/VagrantfileName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) VagrantfilePath(ctx context.Context, in *Machine_VagrantfilePathRequest, opts ...grpc.CallOption) (*Machine_VagrantfilePathResponse, error) {
	out := new(Machine_VagrantfilePathResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/VagrantfilePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) UpdatedAt(ctx context.Context, in *Machine_UpdatedAtRequest, opts ...grpc.CallOption) (*Machine_UpdatedAtResponse, error) {
	out := new(Machine_UpdatedAtResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/UpdatedAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) UI(ctx context.Context, in *Machine_UIRequest, opts ...grpc.CallOption) (*Machine_UIResponse, error) {
	out := new(Machine_UIResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.MachineService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineServiceServer is the server API for MachineService service.
// All implementations must embed UnimplementedMachineServiceServer
// for forward compatibility
type MachineServiceServer interface {
	// Getters and Setters
	SetName(context.Context, *Machine_SetNameRequest) (*Machine_SetNameResponse, error)
	GetName(context.Context, *Machine_GetNameRequest) (*Machine_GetNameResponse, error)
	SetID(context.Context, *Machine_SetIDRequest) (*Machine_SetIDResponse, error)
	GetID(context.Context, *Machine_GetIDRequest) (*Machine_GetIDResponse, error)
	SetState(context.Context, *Machine_SetStateRequest) (*Machine_SetStateResponse, error)
	GetState(context.Context, *Machine_GetStateRequest) (*Machine_GetStateResponse, error)
	SetUUID(context.Context, *Machine_SetUUIDRequest) (*Machine_SetUUIDResponse, error)
	GetUUID(context.Context, *Machine_GetUUIDRequest) (*Machine_GetUUIDResponse, error)
	Box(context.Context, *Machine_BoxRequest) (*Machine_BoxResponse, error)
	Datadir(context.Context, *Machine_DatadirRequest) (*Machine_DatadirResponse, error)
	LocalDataPath(context.Context, *Machine_LocalDataPathRequest) (*Machine_LocalDataPathResponse, error)
	Provider(context.Context, *Machine_ProviderRequest) (*Machine_ProviderResponse, error)
	VagrantfileName(context.Context, *Machine_VagrantfileNameRequest) (*Machine_VagrantfileNameResponse, error)
	VagrantfilePath(context.Context, *Machine_VagrantfilePathRequest) (*Machine_VagrantfilePathResponse, error)
	UpdatedAt(context.Context, *Machine_UpdatedAtRequest) (*Machine_UpdatedAtResponse, error)
	UI(context.Context, *Machine_UIRequest) (*Machine_UIResponse, error)
	mustEmbedUnimplementedMachineServiceServer()
}

// UnimplementedMachineServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMachineServiceServer struct {
}

func (UnimplementedMachineServiceServer) SetName(context.Context, *Machine_SetNameRequest) (*Machine_SetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedMachineServiceServer) GetName(context.Context, *Machine_GetNameRequest) (*Machine_GetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetName not implemented")
}
func (UnimplementedMachineServiceServer) SetID(context.Context, *Machine_SetIDRequest) (*Machine_SetIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetID not implemented")
}
func (UnimplementedMachineServiceServer) GetID(context.Context, *Machine_GetIDRequest) (*Machine_GetIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetID not implemented")
}
func (UnimplementedMachineServiceServer) SetState(context.Context, *Machine_SetStateRequest) (*Machine_SetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetState not implemented")
}
func (UnimplementedMachineServiceServer) GetState(context.Context, *Machine_GetStateRequest) (*Machine_GetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedMachineServiceServer) SetUUID(context.Context, *Machine_SetUUIDRequest) (*Machine_SetUUIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUUID not implemented")
}
func (UnimplementedMachineServiceServer) GetUUID(context.Context, *Machine_GetUUIDRequest) (*Machine_GetUUIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUUID not implemented")
}
func (UnimplementedMachineServiceServer) Box(context.Context, *Machine_BoxRequest) (*Machine_BoxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Box not implemented")
}
func (UnimplementedMachineServiceServer) Datadir(context.Context, *Machine_DatadirRequest) (*Machine_DatadirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Datadir not implemented")
}
func (UnimplementedMachineServiceServer) LocalDataPath(context.Context, *Machine_LocalDataPathRequest) (*Machine_LocalDataPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalDataPath not implemented")
}
func (UnimplementedMachineServiceServer) Provider(context.Context, *Machine_ProviderRequest) (*Machine_ProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedMachineServiceServer) VagrantfileName(context.Context, *Machine_VagrantfileNameRequest) (*Machine_VagrantfileNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfileName not implemented")
}
func (UnimplementedMachineServiceServer) VagrantfilePath(context.Context, *Machine_VagrantfilePathRequest) (*Machine_VagrantfilePathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfilePath not implemented")
}
func (UnimplementedMachineServiceServer) UpdatedAt(context.Context, *Machine_UpdatedAtRequest) (*Machine_UpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatedAt not implemented")
}
func (UnimplementedMachineServiceServer) UI(context.Context, *Machine_UIRequest) (*Machine_UIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedMachineServiceServer) mustEmbedUnimplementedMachineServiceServer() {}

// UnsafeMachineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineServiceServer will
// result in compilation errors.
type UnsafeMachineServiceServer interface {
	mustEmbedUnimplementedMachineServiceServer()
}

func RegisterMachineServiceServer(s grpc.ServiceRegistrar, srv MachineServiceServer) {
	s.RegisterService(&_MachineService_serviceDesc, srv)
}

func _MachineService_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_SetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/SetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetName(ctx, req.(*Machine_SetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_GetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/GetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetName(ctx, req.(*Machine_GetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_SetIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/SetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetID(ctx, req.(*Machine_SetIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_GetIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/GetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetID(ctx, req.(*Machine_GetIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_SetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/SetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetState(ctx, req.(*Machine_SetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_GetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetState(ctx, req.(*Machine_GetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_SetUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/SetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetUUID(ctx, req.(*Machine_SetUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_GetUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/GetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetUUID(ctx, req.(*Machine_GetUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Box_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_BoxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Box(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/Box",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Box(ctx, req.(*Machine_BoxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Datadir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_DatadirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Datadir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/Datadir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Datadir(ctx, req.(*Machine_DatadirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_LocalDataPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_LocalDataPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).LocalDataPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/LocalDataPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).LocalDataPath(ctx, req.(*Machine_LocalDataPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_ProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Provider(ctx, req.(*Machine_ProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_VagrantfileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_VagrantfileNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).VagrantfileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/VagrantfileName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).VagrantfileName(ctx, req.(*Machine_VagrantfileNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_VagrantfilePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_VagrantfilePathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).VagrantfilePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/VagrantfilePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).VagrantfilePath(ctx, req.(*Machine_VagrantfilePathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_UpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_UpdatedAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).UpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/UpdatedAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).UpdatedAt(ctx, req.(*Machine_UpdatedAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Machine_UIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.MachineService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).UI(ctx, req.(*Machine_UIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MachineService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.MachineService",
	HandlerType: (*MachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetName",
			Handler:    _MachineService_SetName_Handler,
		},
		{
			MethodName: "GetName",
			Handler:    _MachineService_GetName_Handler,
		},
		{
			MethodName: "SetID",
			Handler:    _MachineService_SetID_Handler,
		},
		{
			MethodName: "GetID",
			Handler:    _MachineService_GetID_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _MachineService_SetState_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _MachineService_GetState_Handler,
		},
		{
			MethodName: "SetUUID",
			Handler:    _MachineService_SetUUID_Handler,
		},
		{
			MethodName: "GetUUID",
			Handler:    _MachineService_GetUUID_Handler,
		},
		{
			MethodName: "Box",
			Handler:    _MachineService_Box_Handler,
		},
		{
			MethodName: "Datadir",
			Handler:    _MachineService_Datadir_Handler,
		},
		{
			MethodName: "LocalDataPath",
			Handler:    _MachineService_LocalDataPath_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _MachineService_Provider_Handler,
		},
		{
			MethodName: "VagrantfileName",
			Handler:    _MachineService_VagrantfileName_Handler,
		},
		{
			MethodName: "VagrantfilePath",
			Handler:    _MachineService_VagrantfilePath_Handler,
		},
		{
			MethodName: "UpdatedAt",
			Handler:    _MachineService_UpdatedAt_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _MachineService_UI_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProjectServiceClient is the client API for ProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectServiceClient interface {
	MachineNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_MachineNamesResponse, error)
	ActiveMachines(ctx context.Context, in *Project_ActiveMachinesRequest, opts ...grpc.CallOption) (*Project_ActiveMachinesResponse, error)
}

type projectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {
	return &projectServiceClient{cc}
}

func (c *projectServiceClient) MachineNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_MachineNamesResponse, error) {
	out := new(Project_MachineNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/MachineNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) ActiveMachines(ctx context.Context, in *Project_ActiveMachinesRequest, opts ...grpc.CallOption) (*Project_ActiveMachinesResponse, error) {
	out := new(Project_ActiveMachinesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/ActiveMachines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectServiceServer is the server API for ProjectService service.
// All implementations must embed UnimplementedProjectServiceServer
// for forward compatibility
type ProjectServiceServer interface {
	MachineNames(context.Context, *empty.Empty) (*Project_MachineNamesResponse, error)
	ActiveMachines(context.Context, *Project_ActiveMachinesRequest) (*Project_ActiveMachinesResponse, error)
	mustEmbedUnimplementedProjectServiceServer()
}

// UnimplementedProjectServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProjectServiceServer struct {
}

func (UnimplementedProjectServiceServer) MachineNames(context.Context, *empty.Empty) (*Project_MachineNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MachineNames not implemented")
}
func (UnimplementedProjectServiceServer) ActiveMachines(context.Context, *Project_ActiveMachinesRequest) (*Project_ActiveMachinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveMachines not implemented")
}
func (UnimplementedProjectServiceServer) mustEmbedUnimplementedProjectServiceServer() {}

// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectServiceServer will
// result in compilation errors.
type UnsafeProjectServiceServer interface {
	mustEmbedUnimplementedProjectServiceServer()
}

func RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {
	s.RegisterService(&_ProjectService_serviceDesc, srv)
}

func _ProjectService_MachineNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).MachineNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/MachineNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).MachineNames(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_ActiveMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project_ActiveMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ActiveMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/ActiveMachines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ActiveMachines(ctx, req.(*Project_ActiveMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProjectService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProjectService",
	HandlerType: (*ProjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MachineNames",
			Handler:    _ProjectService_MachineNames_Handler,
		},
		{
			MethodName: "ActiveMachines",
			Handler:    _ProjectService_ActiveMachines_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}
