// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: vagrant_plugin_sdk/plugin.proto

package vagrant_plugin_sdk

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TerminalUIServiceClient is the client API for TerminalUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TerminalUIServiceClient interface {
	Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error)
	IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error)
	IsMachineReadable(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsMachineReadableResponse, error)
}

type terminalUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalUIServiceClient(cc grpc.ClientConnInterface) TerminalUIServiceClient {
	return &terminalUIServiceClient{cc}
}

func (c *terminalUIServiceClient) Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/Output", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &TerminalUIService_ServiceDesc.Streams[0], "/hashicorp.vagrant.sdk.TerminalUIService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalUIServiceEventsClient{stream}
	return x, nil
}

type TerminalUIService_EventsClient interface {
	Send(*TerminalUI_Event) error
	Recv() (*TerminalUI_Response, error)
	grpc.ClientStream
}

type terminalUIServiceEventsClient struct {
	grpc.ClientStream
}

func (x *terminalUIServiceEventsClient) Send(m *TerminalUI_Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalUIServiceEventsClient) Recv() (*TerminalUI_Response, error) {
	m := new(TerminalUI_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalUIServiceClient) IsInteractive(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error) {
	out := new(TerminalUI_IsInteractiveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) IsMachineReadable(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TerminalUI_IsMachineReadableResponse, error) {
	out := new(TerminalUI_IsMachineReadableResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/IsMachineReadable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalUIServiceServer is the server API for TerminalUIService service.
// All implementations should embed UnimplementedTerminalUIServiceServer
// for forward compatibility
type TerminalUIServiceServer interface {
	Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error)
	Events(TerminalUIService_EventsServer) error
	IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error)
	IsMachineReadable(context.Context, *emptypb.Empty) (*TerminalUI_IsMachineReadableResponse, error)
}

// UnimplementedTerminalUIServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTerminalUIServiceServer struct {
}

func (UnimplementedTerminalUIServiceServer) Output(context.Context, *TerminalUI_OutputRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedTerminalUIServiceServer) Events(TerminalUIService_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsInteractive(context.Context, *emptypb.Empty) (*TerminalUI_IsInteractiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInteractive not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsMachineReadable(context.Context, *emptypb.Empty) (*TerminalUI_IsMachineReadableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMachineReadable not implemented")
}

// UnsafeTerminalUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalUIServiceServer will
// result in compilation errors.
type UnsafeTerminalUIServiceServer interface {
	mustEmbedUnimplementedTerminalUIServiceServer()
}

func RegisterTerminalUIServiceServer(s grpc.ServiceRegistrar, srv TerminalUIServiceServer) {
	s.RegisterService(&TerminalUIService_ServiceDesc, srv)
}

func _TerminalUIService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminalUI_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/Output",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).Output(ctx, req.(*TerminalUI_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalUIServiceServer).Events(&terminalUIServiceEventsServer{stream})
}

type TerminalUIService_EventsServer interface {
	Send(*TerminalUI_Response) error
	Recv() (*TerminalUI_Event, error)
	grpc.ServerStream
}

type terminalUIServiceEventsServer struct {
	grpc.ServerStream
}

func (x *terminalUIServiceEventsServer) Send(m *TerminalUI_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalUIServiceEventsServer) Recv() (*TerminalUI_Event, error) {
	m := new(TerminalUI_Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TerminalUIService_IsInteractive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_IsMachineReadable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsMachineReadable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/IsMachineReadable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsMachineReadable(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TerminalUIService_ServiceDesc is the grpc.ServiceDesc for TerminalUIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TerminalUIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TerminalUIService",
	HandlerType: (*TerminalUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _TerminalUIService_Output_Handler,
		},
		{
			MethodName: "IsInteractive",
			Handler:    _TerminalUIService_IsInteractive_Handler,
		},
		{
			MethodName: "IsMachineReadable",
			Handler:    _TerminalUIService_IsMachineReadable_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _TerminalUIService_Events_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// MapperClient is the client API for Mapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapperClient interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error)
}

type mapperClient struct {
	cc grpc.ClientConnInterface
}

func NewMapperClient(cc grpc.ClientConnInterface) MapperClient {
	return &mapperClient{cc}
}

func (c *mapperClient) ListMappers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error) {
	out := new(Map_ListResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/ListMappers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapperClient) Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error) {
	out := new(Map_Response)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/Map", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapperServer is the server API for Mapper service.
// All implementations should embed UnimplementedMapperServer
// for forward compatibility
type MapperServer interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(context.Context, *Map_Request) (*Map_Response, error)
}

// UnimplementedMapperServer should be embedded to have forward compatible implementations.
type UnimplementedMapperServer struct {
}

func (UnimplementedMapperServer) ListMappers(context.Context, *emptypb.Empty) (*Map_ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappers not implemented")
}
func (UnimplementedMapperServer) Map(context.Context, *Map_Request) (*Map_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Map not implemented")
}

// UnsafeMapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapperServer will
// result in compilation errors.
type UnsafeMapperServer interface {
	mustEmbedUnimplementedMapperServer()
}

func RegisterMapperServer(s grpc.ServiceRegistrar, srv MapperServer) {
	s.RegisterService(&Mapper_ServiceDesc, srv)
}

func _Mapper_ListMappers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).ListMappers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/ListMappers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).ListMappers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mapper_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Map_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/Map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).Map(ctx, req.(*Map_Request))
	}
	return interceptor(ctx, in, info, handler)
}

// Mapper_ServiceDesc is the grpc.ServiceDesc for Mapper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mapper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.Mapper",
	HandlerType: (*MapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMappers",
			Handler:    _Mapper_ListMappers_Handler,
		},
		{
			MethodName: "Map",
			Handler:    _Mapper_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// StateBagServiceClient is the client API for StateBagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateBagServiceClient interface {
	Get(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetResponse, error)
	GetOk(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetOkResponse, error)
	Put(ctx context.Context, in *StateBag_PutRequest, opts ...grpc.CallOption) (*StateBag_PutResponse, error)
	Remove(ctx context.Context, in *StateBag_RemoveRequest, opts ...grpc.CallOption) (*StateBag_RemoveResponse, error)
}

type stateBagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateBagServiceClient(cc grpc.ClientConnInterface) StateBagServiceClient {
	return &stateBagServiceClient{cc}
}

func (c *stateBagServiceClient) Get(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetResponse, error) {
	out := new(StateBag_GetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) GetOk(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetOkResponse, error) {
	out := new(StateBag_GetOkResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/GetOk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) Put(ctx context.Context, in *StateBag_PutRequest, opts ...grpc.CallOption) (*StateBag_PutResponse, error) {
	out := new(StateBag_PutResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) Remove(ctx context.Context, in *StateBag_RemoveRequest, opts ...grpc.CallOption) (*StateBag_RemoveResponse, error) {
	out := new(StateBag_RemoveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateBagServiceServer is the server API for StateBagService service.
// All implementations should embed UnimplementedStateBagServiceServer
// for forward compatibility
type StateBagServiceServer interface {
	Get(context.Context, *StateBag_GetRequest) (*StateBag_GetResponse, error)
	GetOk(context.Context, *StateBag_GetRequest) (*StateBag_GetOkResponse, error)
	Put(context.Context, *StateBag_PutRequest) (*StateBag_PutResponse, error)
	Remove(context.Context, *StateBag_RemoveRequest) (*StateBag_RemoveResponse, error)
}

// UnimplementedStateBagServiceServer should be embedded to have forward compatible implementations.
type UnimplementedStateBagServiceServer struct {
}

func (UnimplementedStateBagServiceServer) Get(context.Context, *StateBag_GetRequest) (*StateBag_GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStateBagServiceServer) GetOk(context.Context, *StateBag_GetRequest) (*StateBag_GetOkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOk not implemented")
}
func (UnimplementedStateBagServiceServer) Put(context.Context, *StateBag_PutRequest) (*StateBag_PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedStateBagServiceServer) Remove(context.Context, *StateBag_RemoveRequest) (*StateBag_RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}

// UnsafeStateBagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateBagServiceServer will
// result in compilation errors.
type UnsafeStateBagServiceServer interface {
	mustEmbedUnimplementedStateBagServiceServer()
}

func RegisterStateBagServiceServer(s grpc.ServiceRegistrar, srv StateBagServiceServer) {
	s.RegisterService(&StateBagService_ServiceDesc, srv)
}

func _StateBagService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Get(ctx, req.(*StateBag_GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_GetOk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).GetOk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/GetOk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).GetOk(ctx, req.(*StateBag_GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Put(ctx, req.(*StateBag_PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Remove(ctx, req.(*StateBag_RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StateBagService_ServiceDesc is the grpc.ServiceDesc for StateBagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StateBagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.StateBagService",
	HandlerType: (*StateBagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StateBagService_Get_Handler,
		},
		{
			MethodName: "GetOk",
			Handler:    _StateBagService_GetOk_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _StateBagService_Put_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _StateBagService_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// PluginInfoServiceClient is the client API for PluginInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginInfoServiceClient interface {
	ComponentTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentList, error)
	ComponentOptions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentOptionsMap, error)
	Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type pluginInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginInfoServiceClient(cc grpc.ClientConnInterface) PluginInfoServiceClient {
	return &pluginInfoServiceClient{cc}
}

func (c *pluginInfoServiceClient) ComponentTypes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentList, error) {
	out := new(PluginInfo_ComponentList)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginInfoService/ComponentTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginInfoServiceClient) ComponentOptions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentOptionsMap, error) {
	out := new(PluginInfo_ComponentOptionsMap)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginInfoService/ComponentOptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginInfoServiceClient) Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginInfoService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginInfoServiceServer is the server API for PluginInfoService service.
// All implementations should embed UnimplementedPluginInfoServiceServer
// for forward compatibility
type PluginInfoServiceServer interface {
	ComponentTypes(context.Context, *emptypb.Empty) (*PluginInfo_ComponentList, error)
	ComponentOptions(context.Context, *emptypb.Empty) (*PluginInfo_ComponentOptionsMap, error)
	Name(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedPluginInfoServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPluginInfoServiceServer struct {
}

func (UnimplementedPluginInfoServiceServer) ComponentTypes(context.Context, *emptypb.Empty) (*PluginInfo_ComponentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComponentTypes not implemented")
}
func (UnimplementedPluginInfoServiceServer) ComponentOptions(context.Context, *emptypb.Empty) (*PluginInfo_ComponentOptionsMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComponentOptions not implemented")
}
func (UnimplementedPluginInfoServiceServer) Name(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}

// UnsafePluginInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginInfoServiceServer will
// result in compilation errors.
type UnsafePluginInfoServiceServer interface {
	mustEmbedUnimplementedPluginInfoServiceServer()
}

func RegisterPluginInfoServiceServer(s grpc.ServiceRegistrar, srv PluginInfoServiceServer) {
	s.RegisterService(&PluginInfoService_ServiceDesc, srv)
}

func _PluginInfoService_ComponentTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginInfoServiceServer).ComponentTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginInfoService/ComponentTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginInfoServiceServer).ComponentTypes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginInfoService_ComponentOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginInfoServiceServer).ComponentOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginInfoService/ComponentOptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginInfoServiceServer).ComponentOptions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginInfoService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginInfoServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginInfoService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginInfoServiceServer).Name(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginInfoService_ServiceDesc is the grpc.ServiceDesc for PluginInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.PluginInfoService",
	HandlerType: (*PluginInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ComponentTypes",
			Handler:    _PluginInfoService_ComponentTypes_Handler,
		},
		{
			MethodName: "ComponentOptions",
			Handler:    _PluginInfoService_ComponentOptions_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _PluginInfoService_Name_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// PluginManagerServiceClient is the client API for PluginManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginManagerServiceClient interface {
	ListPlugins(ctx context.Context, in *PluginManager_PluginsRequest, opts ...grpc.CallOption) (*PluginManager_PluginsResponse, error)
	GetPlugin(ctx context.Context, in *PluginManager_Plugin, opts ...grpc.CallOption) (*PluginManager_Plugin, error)
}

type pluginManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginManagerServiceClient(cc grpc.ClientConnInterface) PluginManagerServiceClient {
	return &pluginManagerServiceClient{cc}
}

func (c *pluginManagerServiceClient) ListPlugins(ctx context.Context, in *PluginManager_PluginsRequest, opts ...grpc.CallOption) (*PluginManager_PluginsResponse, error) {
	out := new(PluginManager_PluginsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginManagerService/ListPlugins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginManagerServiceClient) GetPlugin(ctx context.Context, in *PluginManager_Plugin, opts ...grpc.CallOption) (*PluginManager_Plugin, error) {
	out := new(PluginManager_Plugin)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginManagerService/GetPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginManagerServiceServer is the server API for PluginManagerService service.
// All implementations should embed UnimplementedPluginManagerServiceServer
// for forward compatibility
type PluginManagerServiceServer interface {
	ListPlugins(context.Context, *PluginManager_PluginsRequest) (*PluginManager_PluginsResponse, error)
	GetPlugin(context.Context, *PluginManager_Plugin) (*PluginManager_Plugin, error)
}

// UnimplementedPluginManagerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPluginManagerServiceServer struct {
}

func (UnimplementedPluginManagerServiceServer) ListPlugins(context.Context, *PluginManager_PluginsRequest) (*PluginManager_PluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedPluginManagerServiceServer) GetPlugin(context.Context, *PluginManager_Plugin) (*PluginManager_Plugin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlugin not implemented")
}

// UnsafePluginManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginManagerServiceServer will
// result in compilation errors.
type UnsafePluginManagerServiceServer interface {
	mustEmbedUnimplementedPluginManagerServiceServer()
}

func RegisterPluginManagerServiceServer(s grpc.ServiceRegistrar, srv PluginManagerServiceServer) {
	s.RegisterService(&PluginManagerService_ServiceDesc, srv)
}

func _PluginManagerService_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginManager_PluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginManagerService/ListPlugins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).ListPlugins(ctx, req.(*PluginManager_PluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginManagerService_GetPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginManager_Plugin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginManagerServiceServer).GetPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginManagerService/GetPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginManagerServiceServer).GetPlugin(ctx, req.(*PluginManager_Plugin))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginManagerService_ServiceDesc is the grpc.ServiceDesc for PluginManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.PluginManagerService",
	HandlerType: (*PluginManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPlugins",
			Handler:    _PluginManagerService_ListPlugins_Handler,
		},
		{
			MethodName: "GetPlugin",
			Handler:    _PluginManagerService_GetPlugin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CorePluginManagerServiceClient is the client API for CorePluginManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CorePluginManagerServiceClient interface {
	GetPlugin(ctx context.Context, in *CorePluginManager_GetPluginRequest, opts ...grpc.CallOption) (*CorePluginManager_GetPluginResponse, error)
}

type corePluginManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCorePluginManagerServiceClient(cc grpc.ClientConnInterface) CorePluginManagerServiceClient {
	return &corePluginManagerServiceClient{cc}
}

func (c *corePluginManagerServiceClient) GetPlugin(ctx context.Context, in *CorePluginManager_GetPluginRequest, opts ...grpc.CallOption) (*CorePluginManager_GetPluginResponse, error) {
	out := new(CorePluginManager_GetPluginResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CorePluginManagerService/GetPlugin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CorePluginManagerServiceServer is the server API for CorePluginManagerService service.
// All implementations should embed UnimplementedCorePluginManagerServiceServer
// for forward compatibility
type CorePluginManagerServiceServer interface {
	GetPlugin(context.Context, *CorePluginManager_GetPluginRequest) (*CorePluginManager_GetPluginResponse, error)
}

// UnimplementedCorePluginManagerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCorePluginManagerServiceServer struct {
}

func (UnimplementedCorePluginManagerServiceServer) GetPlugin(context.Context, *CorePluginManager_GetPluginRequest) (*CorePluginManager_GetPluginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlugin not implemented")
}

// UnsafeCorePluginManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CorePluginManagerServiceServer will
// result in compilation errors.
type UnsafeCorePluginManagerServiceServer interface {
	mustEmbedUnimplementedCorePluginManagerServiceServer()
}

func RegisterCorePluginManagerServiceServer(s grpc.ServiceRegistrar, srv CorePluginManagerServiceServer) {
	s.RegisterService(&CorePluginManagerService_ServiceDesc, srv)
}

func _CorePluginManagerService_GetPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CorePluginManager_GetPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorePluginManagerServiceServer).GetPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CorePluginManagerService/GetPlugin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorePluginManagerServiceServer).GetPlugin(ctx, req.(*CorePluginManager_GetPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CorePluginManagerService_ServiceDesc is the grpc.ServiceDesc for CorePluginManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CorePluginManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CorePluginManagerService",
	HandlerType: (*CorePluginManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlugin",
			Handler:    _CorePluginManagerService_GetPlugin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProviderServiceClient is the client API for ProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProviderServiceClient interface {
	Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error)
	UsableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error)
	InstalledSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Action(ctx context.Context, in *Provider_ActionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ActionSpec(ctx context.Context, in *Provider_ActionRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	MachineIdChanged(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	MachineIdChangedSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	SshInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Args_Connection_SSHInfo, error)
	SshInfoSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	State(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Args_Target_Machine_State, error)
	StateSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type providerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProviderServiceClient(cc grpc.ClientConnInterface) ProviderServiceClient {
	return &providerServiceClient{cc}
}

func (c *providerServiceClient) Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error) {
	out := new(Provider_UsableResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Usable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) UsableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/UsableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error) {
	out := new(Provider_InstalledResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Installed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) InstalledSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Action(ctx context.Context, in *Provider_ActionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Action", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ActionSpec(ctx context.Context, in *Provider_ActionRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ActionSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) MachineIdChanged(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/MachineIdChanged", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) MachineIdChangedSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/MachineIdChangedSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) SshInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Args_Connection_SSHInfo, error) {
	out := new(Args_Connection_SSHInfo)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/SshInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) SshInfoSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/SshInfoSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) State(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Args_Target_Machine_State, error) {
	out := new(Args_Target_Machine_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/State", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) StateSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/StateSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProviderServiceServer is the server API for ProviderService service.
// All implementations should embed UnimplementedProviderServiceServer
// for forward compatibility
type ProviderServiceServer interface {
	Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error)
	UsableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error)
	InstalledSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Action(context.Context, *Provider_ActionRequest) (*emptypb.Empty, error)
	ActionSpec(context.Context, *Provider_ActionRequest) (*FuncSpec, error)
	MachineIdChanged(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	MachineIdChangedSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	SshInfo(context.Context, *FuncSpec_Args) (*Args_Connection_SSHInfo, error)
	SshInfoSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	State(context.Context, *FuncSpec_Args) (*Args_Target_Machine_State, error)
	StateSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedProviderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProviderServiceServer struct {
}

func (UnimplementedProviderServiceServer) Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Usable not implemented")
}
func (UnimplementedProviderServiceServer) UsableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsableSpec not implemented")
}
func (UnimplementedProviderServiceServer) Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Installed not implemented")
}
func (UnimplementedProviderServiceServer) InstalledSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstalledSpec not implemented")
}
func (UnimplementedProviderServiceServer) Action(context.Context, *Provider_ActionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Action not implemented")
}
func (UnimplementedProviderServiceServer) ActionSpec(context.Context, *Provider_ActionRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionSpec not implemented")
}
func (UnimplementedProviderServiceServer) MachineIdChanged(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MachineIdChanged not implemented")
}
func (UnimplementedProviderServiceServer) MachineIdChangedSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MachineIdChangedSpec not implemented")
}
func (UnimplementedProviderServiceServer) SshInfo(context.Context, *FuncSpec_Args) (*Args_Connection_SSHInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SshInfo not implemented")
}
func (UnimplementedProviderServiceServer) SshInfoSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SshInfoSpec not implemented")
}
func (UnimplementedProviderServiceServer) State(context.Context, *FuncSpec_Args) (*Args_Target_Machine_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedProviderServiceServer) StateSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StateSpec not implemented")
}
func (UnimplementedProviderServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedProviderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProviderServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedProviderServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedProviderServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedProviderServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedProviderServiceServer) HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedProviderServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedProviderServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedProviderServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedProviderServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProviderServiceServer will
// result in compilation errors.
type UnsafeProviderServiceServer interface {
	mustEmbedUnimplementedProviderServiceServer()
}

func RegisterProviderServiceServer(s grpc.ServiceRegistrar, srv ProviderServiceServer) {
	s.RegisterService(&ProviderService_ServiceDesc, srv)
}

func _ProviderService_Usable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Usable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Usable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Usable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_UsableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).UsableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/UsableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).UsableSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Installed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Installed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Installed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Installed(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_InstalledSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Action_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Provider_ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Action(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Action",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Action(ctx, req.(*Provider_ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ActionSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Provider_ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ActionSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ActionSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ActionSpec(ctx, req.(*Provider_ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_MachineIdChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).MachineIdChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/MachineIdChanged",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).MachineIdChanged(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_MachineIdChangedSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).MachineIdChangedSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/MachineIdChangedSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).MachineIdChangedSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_SshInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).SshInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/SshInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).SshInfo(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_SshInfoSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).SshInfoSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/SshInfoSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).SshInfoSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/State",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).State(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_StateSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).StateSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/StateSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).StateSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).HasCapabilitySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ProviderService_ServiceDesc is the grpc.ServiceDesc for ProviderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProviderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProviderService",
	HandlerType: (*ProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Usable",
			Handler:    _ProviderService_Usable_Handler,
		},
		{
			MethodName: "UsableSpec",
			Handler:    _ProviderService_UsableSpec_Handler,
		},
		{
			MethodName: "Installed",
			Handler:    _ProviderService_Installed_Handler,
		},
		{
			MethodName: "InstalledSpec",
			Handler:    _ProviderService_InstalledSpec_Handler,
		},
		{
			MethodName: "Action",
			Handler:    _ProviderService_Action_Handler,
		},
		{
			MethodName: "ActionSpec",
			Handler:    _ProviderService_ActionSpec_Handler,
		},
		{
			MethodName: "MachineIdChanged",
			Handler:    _ProviderService_MachineIdChanged_Handler,
		},
		{
			MethodName: "MachineIdChangedSpec",
			Handler:    _ProviderService_MachineIdChangedSpec_Handler,
		},
		{
			MethodName: "SshInfo",
			Handler:    _ProviderService_SshInfo_Handler,
		},
		{
			MethodName: "SshInfoSpec",
			Handler:    _ProviderService_SshInfoSpec_Handler,
		},
		{
			MethodName: "State",
			Handler:    _ProviderService_State_Handler,
		},
		{
			MethodName: "StateSpec",
			Handler:    _ProviderService_StateSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _ProviderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProviderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ProviderService_Documentation_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _ProviderService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _ProviderService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _ProviderService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _ProviderService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _ProviderService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _ProviderService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _ProviderService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _ProviderService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProvisionerServiceClient is the client API for ProvisionerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProvisionerServiceClient interface {
	ConfigureSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Configure(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ProvisionSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Provision(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CleanupSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Cleanup(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type provisionerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProvisionerServiceClient(cc grpc.ClientConnInterface) ProvisionerServiceClient {
	return &provisionerServiceClient{cc}
}

func (c *provisionerServiceClient) ConfigureSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/ConfigureSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Configure(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) ProvisionSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/ProvisionSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Provision(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Provision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) CleanupSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/CleanupSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Cleanup(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Cleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProvisionerServiceServer is the server API for ProvisionerService service.
// All implementations should embed UnimplementedProvisionerServiceServer
// for forward compatibility
type ProvisionerServiceServer interface {
	ConfigureSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Configure(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ProvisionSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Provision(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	CleanupSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Cleanup(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedProvisionerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProvisionerServiceServer struct {
}

func (UnimplementedProvisionerServiceServer) ConfigureSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureSpec not implemented")
}
func (UnimplementedProvisionerServiceServer) Configure(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProvisionerServiceServer) ProvisionSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProvisionSpec not implemented")
}
func (UnimplementedProvisionerServiceServer) Provision(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provision not implemented")
}
func (UnimplementedProvisionerServiceServer) CleanupSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupSpec not implemented")
}
func (UnimplementedProvisionerServiceServer) Cleanup(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedProvisionerServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedProvisionerServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedProvisionerServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedProvisionerServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeProvisionerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProvisionerServiceServer will
// result in compilation errors.
type UnsafeProvisionerServiceServer interface {
	mustEmbedUnimplementedProvisionerServiceServer()
}

func RegisterProvisionerServiceServer(s grpc.ServiceRegistrar, srv ProvisionerServiceServer) {
	s.RegisterService(&ProvisionerService_ServiceDesc, srv)
}

func _ProvisionerService_ConfigureSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).ConfigureSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/ConfigureSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).ConfigureSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Configure(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_ProvisionSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).ProvisionSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/ProvisionSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).ProvisionSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Provision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Provision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Provision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Provision(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_CleanupSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).CleanupSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/CleanupSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).CleanupSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Cleanup(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ProvisionerService_ServiceDesc is the grpc.ServiceDesc for ProvisionerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProvisionerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProvisionerService",
	HandlerType: (*ProvisionerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigureSpec",
			Handler:    _ProvisionerService_ConfigureSpec_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProvisionerService_Configure_Handler,
		},
		{
			MethodName: "ProvisionSpec",
			Handler:    _ProvisionerService_ProvisionSpec_Handler,
		},
		{
			MethodName: "Provision",
			Handler:    _ProvisionerService_Provision_Handler,
		},
		{
			MethodName: "CleanupSpec",
			Handler:    _ProvisionerService_CleanupSpec_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _ProvisionerService_Cleanup_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _ProvisionerService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _ProvisionerService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _ProvisionerService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _ProvisionerService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommandServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error)
	CommandInfoSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error) {
	out := new(Command_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfoSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error) {
	out := new(Command_CommandInfoResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
// All implementations should embed UnimplementedCommandServiceServer
// for forward compatibility
type CommandServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error)
	Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error)
	CommandInfoSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedCommandServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCommandServiceServer struct {
}

func (UnimplementedCommandServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommandServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommandServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommandServiceServer) ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommandServiceServer) Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfoSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfoSpec not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfo not implemented")
}
func (UnimplementedCommandServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedCommandServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedCommandServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedCommandServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	s.RegisterService(&CommandService_ServiceDesc, srv)
}

func _CommandService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteSpecReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, req.(*Command_ExecuteSpecReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Execute(ctx, req.(*Command_ExecuteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfoSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfo(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CommandService_ServiceDesc is the grpc.ServiceDesc for CommandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommandService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommandService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommandService_Documentation_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommandService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommandService_Execute_Handler,
		},
		{
			MethodName: "CommandInfoSpec",
			Handler:    _CommandService_CommandInfoSpec_Handler,
		},
		{
			MethodName: "CommandInfo",
			Handler:    _CommandService_CommandInfo_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _CommandService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _CommandService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _CommandService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _CommandService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommunicatorServiceClient is the client API for CommunicatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommunicatorServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	MatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error)
	InitSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReadySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	WaitForReadySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	DownloadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UploadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ExecuteSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	TestSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error)
	ResetSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type communicatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommunicatorServiceClient(cc grpc.ClientConnInterface) CommunicatorServiceClient {
	return &communicatorServiceClient{cc}
}

func (c *communicatorServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) MatchSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error) {
	out := new(Communicator_MatchResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Match", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) InitSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ReadySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReadySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) DownloadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Download", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) UploadSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ExecuteSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecuteSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) TestSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error) {
	out := new(Communicator_TestResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ResetSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommunicatorServiceServer is the server API for CommunicatorService service.
// All implementations should embed UnimplementedCommunicatorServiceServer
// for forward compatibility
type CommunicatorServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	MatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error)
	InitSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Init(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ReadySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	WaitForReadySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	DownloadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Download(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	UploadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Upload(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	ExecuteSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	TestSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error)
	ResetSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Reset(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedCommunicatorServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCommunicatorServiceServer struct {
}

func (UnimplementedCommunicatorServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommunicatorServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommunicatorServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommunicatorServiceServer) MatchSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Match not implemented")
}
func (UnimplementedCommunicatorServiceServer) InitSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Init(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedCommunicatorServiceServer) ReadySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReadySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReady not implemented")
}
func (UnimplementedCommunicatorServiceServer) DownloadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Download(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedCommunicatorServiceServer) UploadSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Upload(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedCommunicatorServiceServer) ExecuteSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecuteSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecute not implemented")
}
func (UnimplementedCommunicatorServiceServer) TestSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedCommunicatorServiceServer) ResetSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Reset(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedCommunicatorServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedCommunicatorServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedCommunicatorServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedCommunicatorServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeCommunicatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommunicatorServiceServer will
// result in compilation errors.
type UnsafeCommunicatorServiceServer interface {
	mustEmbedUnimplementedCommunicatorServiceServer()
}

func RegisterCommunicatorServiceServer(s grpc.ServiceRegistrar, srv CommunicatorServiceServer) {
	s.RegisterService(&CommunicatorService_ServiceDesc, srv)
}

func _CommunicatorService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_MatchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Match_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Match(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Match",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Match(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_InitSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Init(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Ready(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_DownloadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Download(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_UploadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Upload(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Execute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_TestSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Test(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ResetSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Reset(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CommunicatorService_ServiceDesc is the grpc.ServiceDesc for CommunicatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommunicatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommunicatorService",
	HandlerType: (*CommunicatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommunicatorService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommunicatorService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommunicatorService_Documentation_Handler,
		},
		{
			MethodName: "MatchSpec",
			Handler:    _CommunicatorService_MatchSpec_Handler,
		},
		{
			MethodName: "Match",
			Handler:    _CommunicatorService_Match_Handler,
		},
		{
			MethodName: "InitSpec",
			Handler:    _CommunicatorService_InitSpec_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _CommunicatorService_Init_Handler,
		},
		{
			MethodName: "ReadySpec",
			Handler:    _CommunicatorService_ReadySpec_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _CommunicatorService_Ready_Handler,
		},
		{
			MethodName: "WaitForReadySpec",
			Handler:    _CommunicatorService_WaitForReadySpec_Handler,
		},
		{
			MethodName: "WaitForReady",
			Handler:    _CommunicatorService_WaitForReady_Handler,
		},
		{
			MethodName: "DownloadSpec",
			Handler:    _CommunicatorService_DownloadSpec_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _CommunicatorService_Download_Handler,
		},
		{
			MethodName: "UploadSpec",
			Handler:    _CommunicatorService_UploadSpec_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _CommunicatorService_Upload_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommunicatorService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommunicatorService_Execute_Handler,
		},
		{
			MethodName: "PrivilegedExecuteSpec",
			Handler:    _CommunicatorService_PrivilegedExecuteSpec_Handler,
		},
		{
			MethodName: "PrivilegedExecute",
			Handler:    _CommunicatorService_PrivilegedExecute_Handler,
		},
		{
			MethodName: "TestSpec",
			Handler:    _CommunicatorService_TestSpec_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _CommunicatorService_Test_Handler,
		},
		{
			MethodName: "ResetSpec",
			Handler:    _CommunicatorService_ResetSpec_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _CommunicatorService_Reset_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _CommunicatorService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _CommunicatorService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _CommunicatorService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _CommunicatorService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations should embed UnimplementedConfigServiceServer
// for forward compatibility
type ConfigServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
}

// UnimplementedConfigServiceServer should be embedded to have forward compatible implementations.
type UnimplementedConfigServiceServer struct {
}

func (UnimplementedConfigServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedConfigServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedConfigServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	s.RegisterService(&ConfigService_ServiceDesc, srv)
}

func _ConfigService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigService_ServiceDesc is the grpc.ServiceDesc for ConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ConfigService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ConfigService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ConfigService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// HostServiceClient is the client API for HostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error)
	DetectSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Parent(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentResp, error)
	ParentSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type hostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostServiceClient(cc grpc.ClientConnInterface) HostServiceClient {
	return &hostServiceClient{cc}
}

func (c *hostServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error) {
	out := new(Platform_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) DetectSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Parent(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentResp, error) {
	out := new(Platform_ParentResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Parent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) ParentSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/ParentSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostServiceServer is the server API for HostService service.
// All implementations should embed UnimplementedHostServiceServer
// for forward compatibility
type HostServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error)
	DetectSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Parent(context.Context, *FuncSpec_Args) (*Platform_ParentResp, error)
	ParentSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedHostServiceServer should be embedded to have forward compatible implementations.
type UnimplementedHostServiceServer struct {
}

func (UnimplementedHostServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedHostServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedHostServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedHostServiceServer) Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedHostServiceServer) DetectSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedHostServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedHostServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedHostServiceServer) HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) Parent(context.Context, *FuncSpec_Args) (*Platform_ParentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parent not implemented")
}
func (UnimplementedHostServiceServer) ParentSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParentSpec not implemented")
}
func (UnimplementedHostServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedHostServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedHostServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedHostServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostServiceServer will
// result in compilation errors.
type UnsafeHostServiceServer interface {
	mustEmbedUnimplementedHostServiceServer()
}

func RegisterHostServiceServer(s grpc.ServiceRegistrar, srv HostServiceServer) {
	s.RegisterService(&HostService_ServiceDesc, srv)
}

func _HostService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).DetectSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Parent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Parent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Parent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Parent(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_ParentSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ParentSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/ParentSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ParentSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// HostService_ServiceDesc is the grpc.ServiceDesc for HostService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.HostService",
	HandlerType: (*HostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _HostService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _HostService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _HostService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _HostService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _HostService_DetectSpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _HostService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _HostService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _HostService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _HostService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Parent",
			Handler:    _HostService_Parent_Handler,
		},
		{
			MethodName: "ParentSpec",
			Handler:    _HostService_ParentSpec_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _HostService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _HostService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _HostService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _HostService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// GuestServiceClient is the client API for GuestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error)
	DetectSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Parent(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentResp, error)
	ParentSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type guestServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestServiceClient(cc grpc.ClientConnInterface) GuestServiceClient {
	return &guestServiceClient{cc}
}

func (c *guestServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error) {
	out := new(Platform_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) DetectSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Parent(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentResp, error) {
	out := new(Platform_ParentResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Parent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) ParentSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/ParentSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestServiceServer is the server API for GuestService service.
// All implementations should embed UnimplementedGuestServiceServer
// for forward compatibility
type GuestServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error)
	DetectSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Parent(context.Context, *FuncSpec_Args) (*Platform_ParentResp, error)
	ParentSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedGuestServiceServer should be embedded to have forward compatible implementations.
type UnimplementedGuestServiceServer struct {
}

func (UnimplementedGuestServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedGuestServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedGuestServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedGuestServiceServer) Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedGuestServiceServer) DetectSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedGuestServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedGuestServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedGuestServiceServer) HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) Parent(context.Context, *FuncSpec_Args) (*Platform_ParentResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parent not implemented")
}
func (UnimplementedGuestServiceServer) ParentSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParentSpec not implemented")
}
func (UnimplementedGuestServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedGuestServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedGuestServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedGuestServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeGuestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestServiceServer will
// result in compilation errors.
type UnsafeGuestServiceServer interface {
	mustEmbedUnimplementedGuestServiceServer()
}

func RegisterGuestServiceServer(s grpc.ServiceRegistrar, srv GuestServiceServer) {
	s.RegisterService(&GuestService_ServiceDesc, srv)
}

func _GuestService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).DetectSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Parent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Parent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Parent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Parent(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_ParentSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).ParentSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/ParentSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).ParentSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// GuestService_ServiceDesc is the grpc.ServiceDesc for GuestService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GuestService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.GuestService",
	HandlerType: (*GuestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _GuestService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _GuestService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _GuestService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _GuestService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _GuestService_DetectSpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _GuestService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _GuestService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _GuestService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _GuestService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Parent",
			Handler:    _GuestService_Parent_Handler,
		},
		{
			MethodName: "ParentSpec",
			Handler:    _GuestService_ParentSpec_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _GuestService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _GuestService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _GuestService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _GuestService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// SyncedFolderServiceClient is the client API for SyncedFolderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncedFolderServiceClient interface {
	ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*SyncedFolder_UsableResp, error)
	UsableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Enable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	EnableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Prepare(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PrepareSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Disable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DisableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Cleanup(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CleanupSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type syncedFolderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncedFolderServiceClient(cc grpc.ClientConnInterface) SyncedFolderServiceClient {
	return &syncedFolderServiceClient{cc}
}

func (c *syncedFolderServiceClient) ConfigStruct(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Documentation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*SyncedFolder_UsableResp, error) {
	out := new(SyncedFolder_UsableResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Usable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) UsableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/UsableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Enable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Enable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) EnableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/EnableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Prepare(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) PrepareSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/PrepareSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Disable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Disable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) DisableSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/DisableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Cleanup(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Cleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) CleanupSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/CleanupSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) HasCapabilitySpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncedFolderServiceServer is the server API for SyncedFolderService service.
// All implementations should embed UnimplementedSyncedFolderServiceServer
// for forward compatibility
type SyncedFolderServiceServer interface {
	ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error)
	Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error)
	Usable(context.Context, *FuncSpec_Args) (*SyncedFolder_UsableResp, error)
	UsableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Enable(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	EnableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Prepare(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	PrepareSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Disable(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	DisableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Cleanup(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	CleanupSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedSyncedFolderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSyncedFolderServiceServer struct {
}

func (UnimplementedSyncedFolderServiceServer) ConfigStruct(context.Context, *emptypb.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Documentation(context.Context, *emptypb.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Usable(context.Context, *FuncSpec_Args) (*SyncedFolder_UsableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Usable not implemented")
}
func (UnimplementedSyncedFolderServiceServer) UsableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsableSpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Enable(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (UnimplementedSyncedFolderServiceServer) EnableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableSpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Prepare(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (UnimplementedSyncedFolderServiceServer) PrepareSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareSpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Disable(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (UnimplementedSyncedFolderServiceServer) DisableSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableSpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Cleanup(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedSyncedFolderServiceServer) CleanupSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupSpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedSyncedFolderServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedSyncedFolderServiceServer) HasCapabilitySpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedSyncedFolderServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedSyncedFolderServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafeSyncedFolderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncedFolderServiceServer will
// result in compilation errors.
type UnsafeSyncedFolderServiceServer interface {
	mustEmbedUnimplementedSyncedFolderServiceServer()
}

func RegisterSyncedFolderServiceServer(s grpc.ServiceRegistrar, srv SyncedFolderServiceServer) {
	s.RegisterService(&SyncedFolderService_ServiceDesc, srv)
}

func _SyncedFolderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Usable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Usable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Usable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Usable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_UsableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).UsableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/UsableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).UsableSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Enable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Enable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_EnableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).EnableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/EnableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).EnableSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Prepare(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_PrepareSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).PrepareSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/PrepareSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).PrepareSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Disable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Disable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_DisableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).DisableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/DisableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).DisableSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Cleanup(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_CleanupSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).CleanupSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/CleanupSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).CleanupSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).HasCapabilitySpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SyncedFolderService_ServiceDesc is the grpc.ServiceDesc for SyncedFolderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SyncedFolderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.SyncedFolderService",
	HandlerType: (*SyncedFolderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _SyncedFolderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _SyncedFolderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _SyncedFolderService_Documentation_Handler,
		},
		{
			MethodName: "Usable",
			Handler:    _SyncedFolderService_Usable_Handler,
		},
		{
			MethodName: "UsableSpec",
			Handler:    _SyncedFolderService_UsableSpec_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _SyncedFolderService_Enable_Handler,
		},
		{
			MethodName: "EnableSpec",
			Handler:    _SyncedFolderService_EnableSpec_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _SyncedFolderService_Prepare_Handler,
		},
		{
			MethodName: "PrepareSpec",
			Handler:    _SyncedFolderService_PrepareSpec_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _SyncedFolderService_Disable_Handler,
		},
		{
			MethodName: "DisableSpec",
			Handler:    _SyncedFolderService_DisableSpec_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _SyncedFolderService_Cleanup_Handler,
		},
		{
			MethodName: "CleanupSpec",
			Handler:    _SyncedFolderService_CleanupSpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _SyncedFolderService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _SyncedFolderService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _SyncedFolderService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _SyncedFolderService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _SyncedFolderService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _SyncedFolderService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _SyncedFolderService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _SyncedFolderService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// BasisServiceClient is the client API for BasisService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BasisServiceClient interface {
	CWD(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Basis, error)
	DefaultPrivateKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Host(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Host, error)
	Boxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxCollection, error)
	TargetIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TargetIndex, error)
	ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Basis_ResourceIdResponse, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
}

type basisServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBasisServiceClient(cc grpc.ClientConnInterface) BasisServiceClient {
	return &basisServiceClient{cc}
}

func (c *basisServiceClient) CWD(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/CWD", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Basis, error) {
	out := new(Args_DataDir_Basis)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) DefaultPrivateKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/DefaultPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) Host(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Host, error) {
	out := new(Args_Host)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/Host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) Boxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxCollection, error) {
	out := new(Args_BoxCollection)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/Boxes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) TargetIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TargetIndex, error) {
	out := new(Args_TargetIndex)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/TargetIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Basis_ResourceIdResponse, error) {
	out := new(Basis_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BasisServiceServer is the server API for BasisService service.
// All implementations should embed UnimplementedBasisServiceServer
// for forward compatibility
type BasisServiceServer interface {
	CWD(context.Context, *emptypb.Empty) (*Args_Path, error)
	DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Basis, error)
	DefaultPrivateKey(context.Context, *emptypb.Empty) (*Args_Path, error)
	UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error)
	Host(context.Context, *emptypb.Empty) (*Args_Host, error)
	Boxes(context.Context, *emptypb.Empty) (*Args_BoxCollection, error)
	TargetIndex(context.Context, *emptypb.Empty) (*Args_TargetIndex, error)
	ResourceId(context.Context, *emptypb.Empty) (*Basis_ResourceIdResponse, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
}

// UnimplementedBasisServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBasisServiceServer struct {
}

func (UnimplementedBasisServiceServer) CWD(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CWD not implemented")
}
func (UnimplementedBasisServiceServer) DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Basis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedBasisServiceServer) DefaultPrivateKey(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultPrivateKey not implemented")
}
func (UnimplementedBasisServiceServer) UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedBasisServiceServer) Host(context.Context, *emptypb.Empty) (*Args_Host, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Host not implemented")
}
func (UnimplementedBasisServiceServer) Boxes(context.Context, *emptypb.Empty) (*Args_BoxCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Boxes not implemented")
}
func (UnimplementedBasisServiceServer) TargetIndex(context.Context, *emptypb.Empty) (*Args_TargetIndex, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetIndex not implemented")
}
func (UnimplementedBasisServiceServer) ResourceId(context.Context, *emptypb.Empty) (*Basis_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedBasisServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedBasisServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}

// UnsafeBasisServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BasisServiceServer will
// result in compilation errors.
type UnsafeBasisServiceServer interface {
	mustEmbedUnimplementedBasisServiceServer()
}

func RegisterBasisServiceServer(s grpc.ServiceRegistrar, srv BasisServiceServer) {
	s.RegisterService(&BasisService_ServiceDesc, srv)
}

func _BasisService_CWD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).CWD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/CWD",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).CWD(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).DataDir(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_DefaultPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).DefaultPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/DefaultPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).DefaultPrivateKey(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).UI(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_Host_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).Host(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/Host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).Host(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_Boxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).Boxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/Boxes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).Boxes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_TargetIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).TargetIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/TargetIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).TargetIndex(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).ResourceId(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// BasisService_ServiceDesc is the grpc.ServiceDesc for BasisService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BasisService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.BasisService",
	HandlerType: (*BasisServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CWD",
			Handler:    _BasisService_CWD_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _BasisService_DataDir_Handler,
		},
		{
			MethodName: "DefaultPrivateKey",
			Handler:    _BasisService_DefaultPrivateKey_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _BasisService_UI_Handler,
		},
		{
			MethodName: "Host",
			Handler:    _BasisService_Host_Handler,
		},
		{
			MethodName: "Boxes",
			Handler:    _BasisService_Boxes_Handler,
		},
		{
			MethodName: "TargetIndex",
			Handler:    _BasisService_TargetIndex_Handler,
		},
		{
			MethodName: "ResourceId",
			Handler:    _BasisService_ResourceId_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _BasisService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _BasisService_Seeds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// TargetServiceClient is the client API for TargetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetServiceClient interface {
	ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error)
	Record(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error)
	Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Project(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Project, error)
	Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error)
	DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error)
	State(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_State, error)
	UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Specialize(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*anypb.Any, error)
	Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Provider, error)
	ProviderName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	UpdatedAt(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error)
	Communicate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Communicator, error)
	Save(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetUUID(ctx context.Context, in *Target_SetUUIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUUID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_GetUUIDResponse, error)
	Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type targetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetServiceClient(cc grpc.ClientConnInterface) TargetServiceClient {
	return &targetServiceClient{cc}
}

func (c *targetServiceClient) ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error) {
	out := new(Target_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Record(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error) {
	out := new(Target_RecordResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/SetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Project(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Project, error) {
	out := new(Args_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error) {
	out := new(Args_MetadataSet)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Metadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error) {
	out := new(Args_DataDir_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) State(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_State, error) {
	out := new(Args_Target_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/State", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Specialize(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*anypb.Any, error) {
	out := new(anypb.Any)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Specialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Provider, error) {
	out := new(Args_Provider)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) ProviderName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/ProviderName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) UpdatedAt(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error) {
	out := new(Target_UpdatedAtResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/UpdatedAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Communicate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Communicator, error) {
	out := new(Args_Communicator)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Communicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Save(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) SetUUID(ctx context.Context, in *Target_SetUUIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/SetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) GetUUID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_GetUUIDResponse, error) {
	out := new(Target_GetUUIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/GetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Destroy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetServiceServer is the server API for TargetService service.
// All implementations should embed UnimplementedTargetServiceServer
// for forward compatibility
type TargetServiceServer interface {
	ResourceId(context.Context, *emptypb.Empty) (*Target_ResourceIdResponse, error)
	Record(context.Context, *emptypb.Empty) (*Target_RecordResponse, error)
	Name(context.Context, *emptypb.Empty) (*Target_NameResponse, error)
	SetName(context.Context, *Target_SetNameRequest) (*emptypb.Empty, error)
	Project(context.Context, *emptypb.Empty) (*Args_Project, error)
	Metadata(context.Context, *emptypb.Empty) (*Args_MetadataSet, error)
	DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Target, error)
	State(context.Context, *emptypb.Empty) (*Args_Target_State, error)
	UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error)
	Specialize(context.Context, *anypb.Any) (*anypb.Any, error)
	Provider(context.Context, *emptypb.Empty) (*Args_Provider, error)
	ProviderName(context.Context, *emptypb.Empty) (*Target_NameResponse, error)
	UpdatedAt(context.Context, *emptypb.Empty) (*Target_UpdatedAtResponse, error)
	Communicate(context.Context, *emptypb.Empty) (*Args_Communicator, error)
	Save(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	SetUUID(context.Context, *Target_SetUUIDRequest) (*emptypb.Empty, error)
	GetUUID(context.Context, *emptypb.Empty) (*Target_GetUUIDResponse, error)
	Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedTargetServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTargetServiceServer struct {
}

func (UnimplementedTargetServiceServer) ResourceId(context.Context, *emptypb.Empty) (*Target_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedTargetServiceServer) Record(context.Context, *emptypb.Empty) (*Target_RecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedTargetServiceServer) Name(context.Context, *emptypb.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedTargetServiceServer) SetName(context.Context, *Target_SetNameRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedTargetServiceServer) Project(context.Context, *emptypb.Empty) (*Args_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (UnimplementedTargetServiceServer) Metadata(context.Context, *emptypb.Empty) (*Args_MetadataSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedTargetServiceServer) DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedTargetServiceServer) State(context.Context, *emptypb.Empty) (*Args_Target_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedTargetServiceServer) UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedTargetServiceServer) Specialize(context.Context, *anypb.Any) (*anypb.Any, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Specialize not implemented")
}
func (UnimplementedTargetServiceServer) Provider(context.Context, *emptypb.Empty) (*Args_Provider, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedTargetServiceServer) ProviderName(context.Context, *emptypb.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProviderName not implemented")
}
func (UnimplementedTargetServiceServer) UpdatedAt(context.Context, *emptypb.Empty) (*Target_UpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatedAt not implemented")
}
func (UnimplementedTargetServiceServer) Communicate(context.Context, *emptypb.Empty) (*Args_Communicator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Communicate not implemented")
}
func (UnimplementedTargetServiceServer) Save(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedTargetServiceServer) SetUUID(context.Context, *Target_SetUUIDRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUUID not implemented")
}
func (UnimplementedTargetServiceServer) GetUUID(context.Context, *emptypb.Empty) (*Target_GetUUIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUUID not implemented")
}
func (UnimplementedTargetServiceServer) Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}

// UnsafeTargetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetServiceServer will
// result in compilation errors.
type UnsafeTargetServiceServer interface {
	mustEmbedUnimplementedTargetServiceServer()
}

func RegisterTargetServiceServer(s grpc.ServiceRegistrar, srv TargetServiceServer) {
	s.RegisterService(&TargetService_ServiceDesc, srv)
}

func _TargetService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).ResourceId(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Record(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Name(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/SetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).SetName(ctx, req.(*Target_SetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Project(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Metadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Metadata(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).DataDir(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/State",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).State(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).UI(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Specialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Specialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Specialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Specialize(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Provider(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_ProviderName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).ProviderName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/ProviderName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).ProviderName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_UpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).UpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/UpdatedAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).UpdatedAt(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Communicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Communicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Communicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Communicate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Save(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_SetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).SetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/SetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).SetUUID(ctx, req.(*Target_SetUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_GetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).GetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/GetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).GetUUID(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Destroy(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetService_ServiceDesc is the grpc.ServiceDesc for TargetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TargetService",
	HandlerType: (*TargetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResourceId",
			Handler:    _TargetService_ResourceId_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _TargetService_Record_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _TargetService_Name_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _TargetService_SetName_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _TargetService_Project_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _TargetService_Metadata_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _TargetService_DataDir_Handler,
		},
		{
			MethodName: "State",
			Handler:    _TargetService_State_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _TargetService_UI_Handler,
		},
		{
			MethodName: "Specialize",
			Handler:    _TargetService_Specialize_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _TargetService_Provider_Handler,
		},
		{
			MethodName: "ProviderName",
			Handler:    _TargetService_ProviderName_Handler,
		},
		{
			MethodName: "UpdatedAt",
			Handler:    _TargetService_UpdatedAt_Handler,
		},
		{
			MethodName: "Communicate",
			Handler:    _TargetService_Communicate_Handler,
		},
		{
			MethodName: "Save",
			Handler:    _TargetService_Save_Handler,
		},
		{
			MethodName: "SetUUID",
			Handler:    _TargetService_SetUUID_Handler,
		},
		{
			MethodName: "GetUUID",
			Handler:    _TargetService_GetUUID_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _TargetService_Destroy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// TargetMachineServiceClient is the client API for TargetMachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetMachineServiceClient interface {
	// Required so a machine can properly act as a target
	ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error)
	Record(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error)
	Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Project(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Project, error)
	Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error)
	DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error)
	State(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_State, error)
	UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Specialize(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*anypb.Any, error)
	Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Provider, error)
	ProviderName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	UpdatedAt(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error)
	Communicate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Communicator, error)
	Save(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetUUID(ctx context.Context, in *Target_SetUUIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetUUID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_GetUUIDResponse, error)
	Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Machine specific
	SetID(ctx context.Context, in *Target_Machine_SetIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_GetIDResponse, error)
	SetState(ctx context.Context, in *Target_Machine_SetStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_State, error)
	Box(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Box, error)
	Guest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Guest, error)
	ConnectionInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_ConnectionInfoResponse, error)
	UID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_UIDResponse, error)
	SyncedFolders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_SyncedFoldersResponse, error)
}

type targetMachineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetMachineServiceClient(cc grpc.ClientConnInterface) TargetMachineServiceClient {
	return &targetMachineServiceClient{cc}
}

func (c *targetMachineServiceClient) ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error) {
	out := new(Target_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Record(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error) {
	out := new(Target_RecordResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Project(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Project, error) {
	out := new(Args_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error) {
	out := new(Args_MetadataSet)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Metadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error) {
	out := new(Args_DataDir_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) State(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_State, error) {
	out := new(Args_Target_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/State", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Specialize(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*anypb.Any, error) {
	out := new(anypb.Any)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Specialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Provider, error) {
	out := new(Args_Provider)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) ProviderName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/ProviderName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UpdatedAt(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error) {
	out := new(Target_UpdatedAtResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UpdatedAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Communicate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Communicator, error) {
	out := new(Args_Communicator)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Communicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Save(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetUUID(ctx context.Context, in *Target_SetUUIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetUUID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_GetUUIDResponse, error) {
	out := new(Target_GetUUIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Destroy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetID(ctx context.Context, in *Target_Machine_SetIDRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_GetIDResponse, error) {
	out := new(Target_Machine_GetIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetState(ctx context.Context, in *Target_Machine_SetStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_State, error) {
	out := new(Args_Target_Machine_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Box(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Box, error) {
	out := new(Args_Box)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Box", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Guest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Guest, error) {
	out := new(Args_Guest)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Guest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) ConnectionInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_ConnectionInfoResponse, error) {
	out := new(Target_Machine_ConnectionInfoResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/ConnectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_UIDResponse, error) {
	out := new(Target_Machine_UIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SyncedFolders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Target_Machine_SyncedFoldersResponse, error) {
	out := new(Target_Machine_SyncedFoldersResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SyncedFolders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetMachineServiceServer is the server API for TargetMachineService service.
// All implementations should embed UnimplementedTargetMachineServiceServer
// for forward compatibility
type TargetMachineServiceServer interface {
	// Required so a machine can properly act as a target
	ResourceId(context.Context, *emptypb.Empty) (*Target_ResourceIdResponse, error)
	Record(context.Context, *emptypb.Empty) (*Target_RecordResponse, error)
	Name(context.Context, *emptypb.Empty) (*Target_NameResponse, error)
	SetName(context.Context, *Target_SetNameRequest) (*emptypb.Empty, error)
	Project(context.Context, *emptypb.Empty) (*Args_Project, error)
	Metadata(context.Context, *emptypb.Empty) (*Args_MetadataSet, error)
	DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Target, error)
	State(context.Context, *emptypb.Empty) (*Args_Target_State, error)
	UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error)
	Specialize(context.Context, *anypb.Any) (*anypb.Any, error)
	Provider(context.Context, *emptypb.Empty) (*Args_Provider, error)
	ProviderName(context.Context, *emptypb.Empty) (*Target_NameResponse, error)
	UpdatedAt(context.Context, *emptypb.Empty) (*Target_UpdatedAtResponse, error)
	Communicate(context.Context, *emptypb.Empty) (*Args_Communicator, error)
	Save(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	SetUUID(context.Context, *Target_SetUUIDRequest) (*emptypb.Empty, error)
	GetUUID(context.Context, *emptypb.Empty) (*Target_GetUUIDResponse, error)
	Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Machine specific
	SetID(context.Context, *Target_Machine_SetIDRequest) (*emptypb.Empty, error)
	GetID(context.Context, *emptypb.Empty) (*Target_Machine_GetIDResponse, error)
	SetState(context.Context, *Target_Machine_SetStateRequest) (*emptypb.Empty, error)
	GetState(context.Context, *emptypb.Empty) (*Args_Target_Machine_State, error)
	Box(context.Context, *emptypb.Empty) (*Args_Box, error)
	Guest(context.Context, *emptypb.Empty) (*Args_Guest, error)
	ConnectionInfo(context.Context, *emptypb.Empty) (*Target_Machine_ConnectionInfoResponse, error)
	UID(context.Context, *emptypb.Empty) (*Target_Machine_UIDResponse, error)
	SyncedFolders(context.Context, *emptypb.Empty) (*Target_Machine_SyncedFoldersResponse, error)
}

// UnimplementedTargetMachineServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTargetMachineServiceServer struct {
}

func (UnimplementedTargetMachineServiceServer) ResourceId(context.Context, *emptypb.Empty) (*Target_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedTargetMachineServiceServer) Record(context.Context, *emptypb.Empty) (*Target_RecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedTargetMachineServiceServer) Name(context.Context, *emptypb.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetName(context.Context, *Target_SetNameRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedTargetMachineServiceServer) Project(context.Context, *emptypb.Empty) (*Args_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (UnimplementedTargetMachineServiceServer) Metadata(context.Context, *emptypb.Empty) (*Args_MetadataSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedTargetMachineServiceServer) DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedTargetMachineServiceServer) State(context.Context, *emptypb.Empty) (*Args_Target_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedTargetMachineServiceServer) UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedTargetMachineServiceServer) Specialize(context.Context, *anypb.Any) (*anypb.Any, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Specialize not implemented")
}
func (UnimplementedTargetMachineServiceServer) Provider(context.Context, *emptypb.Empty) (*Args_Provider, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedTargetMachineServiceServer) ProviderName(context.Context, *emptypb.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProviderName not implemented")
}
func (UnimplementedTargetMachineServiceServer) UpdatedAt(context.Context, *emptypb.Empty) (*Target_UpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatedAt not implemented")
}
func (UnimplementedTargetMachineServiceServer) Communicate(context.Context, *emptypb.Empty) (*Args_Communicator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Communicate not implemented")
}
func (UnimplementedTargetMachineServiceServer) Save(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetUUID(context.Context, *Target_SetUUIDRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUUID not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetUUID(context.Context, *emptypb.Empty) (*Target_GetUUIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUUID not implemented")
}
func (UnimplementedTargetMachineServiceServer) Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetID(context.Context, *Target_Machine_SetIDRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetID not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetID(context.Context, *emptypb.Empty) (*Target_Machine_GetIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetID not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetState(context.Context, *Target_Machine_SetStateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetState not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetState(context.Context, *emptypb.Empty) (*Args_Target_Machine_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedTargetMachineServiceServer) Box(context.Context, *emptypb.Empty) (*Args_Box, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Box not implemented")
}
func (UnimplementedTargetMachineServiceServer) Guest(context.Context, *emptypb.Empty) (*Args_Guest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Guest not implemented")
}
func (UnimplementedTargetMachineServiceServer) ConnectionInfo(context.Context, *emptypb.Empty) (*Target_Machine_ConnectionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectionInfo not implemented")
}
func (UnimplementedTargetMachineServiceServer) UID(context.Context, *emptypb.Empty) (*Target_Machine_UIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UID not implemented")
}
func (UnimplementedTargetMachineServiceServer) SyncedFolders(context.Context, *emptypb.Empty) (*Target_Machine_SyncedFoldersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncedFolders not implemented")
}

// UnsafeTargetMachineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetMachineServiceServer will
// result in compilation errors.
type UnsafeTargetMachineServiceServer interface {
	mustEmbedUnimplementedTargetMachineServiceServer()
}

func RegisterTargetMachineServiceServer(s grpc.ServiceRegistrar, srv TargetMachineServiceServer) {
	s.RegisterService(&TargetMachineService_ServiceDesc, srv)
}

func _TargetMachineService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).ResourceId(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Record(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Name(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetName(ctx, req.(*Target_SetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Project(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Metadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Metadata(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).DataDir(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/State",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).State(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UI(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Specialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Specialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Specialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Specialize(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Provider(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_ProviderName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).ProviderName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/ProviderName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).ProviderName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UpdatedAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UpdatedAt(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Communicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Communicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Communicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Communicate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Save(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetUUID(ctx, req.(*Target_SetUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetUUID(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Destroy(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_Machine_SetIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetID(ctx, req.(*Target_Machine_SetIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetID(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_Machine_SetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetState(ctx, req.(*Target_Machine_SetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetState(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Box_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Box(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Box",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Box(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Guest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Guest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Guest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Guest(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_ConnectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).ConnectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/ConnectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).ConnectionInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UID(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SyncedFolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SyncedFolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SyncedFolders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SyncedFolders(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetMachineService_ServiceDesc is the grpc.ServiceDesc for TargetMachineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetMachineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TargetMachineService",
	HandlerType: (*TargetMachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResourceId",
			Handler:    _TargetMachineService_ResourceId_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _TargetMachineService_Record_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _TargetMachineService_Name_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _TargetMachineService_SetName_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _TargetMachineService_Project_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _TargetMachineService_Metadata_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _TargetMachineService_DataDir_Handler,
		},
		{
			MethodName: "State",
			Handler:    _TargetMachineService_State_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _TargetMachineService_UI_Handler,
		},
		{
			MethodName: "Specialize",
			Handler:    _TargetMachineService_Specialize_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _TargetMachineService_Provider_Handler,
		},
		{
			MethodName: "ProviderName",
			Handler:    _TargetMachineService_ProviderName_Handler,
		},
		{
			MethodName: "UpdatedAt",
			Handler:    _TargetMachineService_UpdatedAt_Handler,
		},
		{
			MethodName: "Communicate",
			Handler:    _TargetMachineService_Communicate_Handler,
		},
		{
			MethodName: "Save",
			Handler:    _TargetMachineService_Save_Handler,
		},
		{
			MethodName: "SetUUID",
			Handler:    _TargetMachineService_SetUUID_Handler,
		},
		{
			MethodName: "GetUUID",
			Handler:    _TargetMachineService_GetUUID_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _TargetMachineService_Destroy_Handler,
		},
		{
			MethodName: "SetID",
			Handler:    _TargetMachineService_SetID_Handler,
		},
		{
			MethodName: "GetID",
			Handler:    _TargetMachineService_GetID_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _TargetMachineService_SetState_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _TargetMachineService_GetState_Handler,
		},
		{
			MethodName: "Box",
			Handler:    _TargetMachineService_Box_Handler,
		},
		{
			MethodName: "Guest",
			Handler:    _TargetMachineService_Guest_Handler,
		},
		{
			MethodName: "ConnectionInfo",
			Handler:    _TargetMachineService_ConnectionInfo_Handler,
		},
		{
			MethodName: "UID",
			Handler:    _TargetMachineService_UID_Handler,
		},
		{
			MethodName: "SyncedFolders",
			Handler:    _TargetMachineService_SyncedFolders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProjectServiceClient is the client API for ProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectServiceClient interface {
	ActiveTargets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ActiveTargetsResponse, error)
	Boxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxCollection, error)
	Config(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ConfigResponse, error)
	CWD(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Project, error)
	DefaultPrivateKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	DefaultProvider(ctx context.Context, in *Project_DefaultProviderRequest, opts ...grpc.CallOption) (*Project_DefaultProviderResponse, error)
	Home(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	Host(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Host, error)
	LocalData(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	PrimaryTargetName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_PrimaryTargetNameResponse, error)
	ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ResourceIdResponse, error)
	RootPath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	Target(ctx context.Context, in *Project_TargetRequest, opts ...grpc.CallOption) (*Args_Target, error)
	TargetIds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_TargetIdsResponse, error)
	TargetIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TargetIndex, error)
	TargetNames(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_TargetNamesResponse, error)
	Tmp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	VagrantfileName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_VagrantfileNameResponse, error)
	VagrantfilePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
}

type projectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {
	return &projectServiceClient{cc}
}

func (c *projectServiceClient) ActiveTargets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ActiveTargetsResponse, error) {
	out := new(Project_ActiveTargetsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/ActiveTargets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Boxes(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxCollection, error) {
	out := new(Args_BoxCollection)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Boxes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Config(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ConfigResponse, error) {
	out := new(Project_ConfigResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Config", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) CWD(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/CWD", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DataDir(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_DataDir_Project, error) {
	out := new(Args_DataDir_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DefaultPrivateKey(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/DefaultPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DefaultProvider(ctx context.Context, in *Project_DefaultProviderRequest, opts ...grpc.CallOption) (*Project_DefaultProviderResponse, error) {
	out := new(Project_DefaultProviderResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/DefaultProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Home(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Home", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Host(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Host, error) {
	out := new(Args_Host)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) LocalData(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/LocalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) PrimaryTargetName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_PrimaryTargetNameResponse, error) {
	out := new(Project_PrimaryTargetNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/PrimaryTargetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) ResourceId(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_ResourceIdResponse, error) {
	out := new(Project_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) RootPath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/RootPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Target(ctx context.Context, in *Project_TargetRequest, opts ...grpc.CallOption) (*Args_Target, error) {
	out := new(Args_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Target", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) TargetIds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_TargetIdsResponse, error) {
	out := new(Project_TargetIdsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/TargetIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) TargetIndex(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TargetIndex, error) {
	out := new(Args_TargetIndex)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/TargetIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) TargetNames(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_TargetNamesResponse, error) {
	out := new(Project_TargetNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/TargetNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Tmp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Tmp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) UI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) VagrantfileName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Project_VagrantfileNameResponse, error) {
	out := new(Project_VagrantfileNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/VagrantfileName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) VagrantfilePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/VagrantfilePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectServiceServer is the server API for ProjectService service.
// All implementations should embed UnimplementedProjectServiceServer
// for forward compatibility
type ProjectServiceServer interface {
	ActiveTargets(context.Context, *emptypb.Empty) (*Project_ActiveTargetsResponse, error)
	Boxes(context.Context, *emptypb.Empty) (*Args_BoxCollection, error)
	Config(context.Context, *emptypb.Empty) (*Project_ConfigResponse, error)
	CWD(context.Context, *emptypb.Empty) (*Args_Path, error)
	DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Project, error)
	DefaultPrivateKey(context.Context, *emptypb.Empty) (*Args_Path, error)
	DefaultProvider(context.Context, *Project_DefaultProviderRequest) (*Project_DefaultProviderResponse, error)
	Home(context.Context, *emptypb.Empty) (*Args_Path, error)
	Host(context.Context, *emptypb.Empty) (*Args_Host, error)
	LocalData(context.Context, *emptypb.Empty) (*Args_Path, error)
	PrimaryTargetName(context.Context, *emptypb.Empty) (*Project_PrimaryTargetNameResponse, error)
	ResourceId(context.Context, *emptypb.Empty) (*Project_ResourceIdResponse, error)
	RootPath(context.Context, *emptypb.Empty) (*Args_Path, error)
	Target(context.Context, *Project_TargetRequest) (*Args_Target, error)
	TargetIds(context.Context, *emptypb.Empty) (*Project_TargetIdsResponse, error)
	TargetIndex(context.Context, *emptypb.Empty) (*Args_TargetIndex, error)
	TargetNames(context.Context, *emptypb.Empty) (*Project_TargetNamesResponse, error)
	Tmp(context.Context, *emptypb.Empty) (*Args_Path, error)
	UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error)
	VagrantfileName(context.Context, *emptypb.Empty) (*Project_VagrantfileNameResponse, error)
	VagrantfilePath(context.Context, *emptypb.Empty) (*Args_Path, error)
}

// UnimplementedProjectServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProjectServiceServer struct {
}

func (UnimplementedProjectServiceServer) ActiveTargets(context.Context, *emptypb.Empty) (*Project_ActiveTargetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActiveTargets not implemented")
}
func (UnimplementedProjectServiceServer) Boxes(context.Context, *emptypb.Empty) (*Args_BoxCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Boxes not implemented")
}
func (UnimplementedProjectServiceServer) Config(context.Context, *emptypb.Empty) (*Project_ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedProjectServiceServer) CWD(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CWD not implemented")
}
func (UnimplementedProjectServiceServer) DataDir(context.Context, *emptypb.Empty) (*Args_DataDir_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedProjectServiceServer) DefaultPrivateKey(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultPrivateKey not implemented")
}
func (UnimplementedProjectServiceServer) DefaultProvider(context.Context, *Project_DefaultProviderRequest) (*Project_DefaultProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultProvider not implemented")
}
func (UnimplementedProjectServiceServer) Home(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Home not implemented")
}
func (UnimplementedProjectServiceServer) Host(context.Context, *emptypb.Empty) (*Args_Host, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Host not implemented")
}
func (UnimplementedProjectServiceServer) LocalData(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalData not implemented")
}
func (UnimplementedProjectServiceServer) PrimaryTargetName(context.Context, *emptypb.Empty) (*Project_PrimaryTargetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrimaryTargetName not implemented")
}
func (UnimplementedProjectServiceServer) ResourceId(context.Context, *emptypb.Empty) (*Project_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedProjectServiceServer) RootPath(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RootPath not implemented")
}
func (UnimplementedProjectServiceServer) Target(context.Context, *Project_TargetRequest) (*Args_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Target not implemented")
}
func (UnimplementedProjectServiceServer) TargetIds(context.Context, *emptypb.Empty) (*Project_TargetIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetIds not implemented")
}
func (UnimplementedProjectServiceServer) TargetIndex(context.Context, *emptypb.Empty) (*Args_TargetIndex, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetIndex not implemented")
}
func (UnimplementedProjectServiceServer) TargetNames(context.Context, *emptypb.Empty) (*Project_TargetNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetNames not implemented")
}
func (UnimplementedProjectServiceServer) Tmp(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tmp not implemented")
}
func (UnimplementedProjectServiceServer) UI(context.Context, *emptypb.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedProjectServiceServer) VagrantfileName(context.Context, *emptypb.Empty) (*Project_VagrantfileNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfileName not implemented")
}
func (UnimplementedProjectServiceServer) VagrantfilePath(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfilePath not implemented")
}

// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectServiceServer will
// result in compilation errors.
type UnsafeProjectServiceServer interface {
	mustEmbedUnimplementedProjectServiceServer()
}

func RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {
	s.RegisterService(&ProjectService_ServiceDesc, srv)
}

func _ProjectService_ActiveTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ActiveTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/ActiveTargets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ActiveTargets(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Boxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Boxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Boxes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Boxes(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Config",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Config(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_CWD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).CWD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/CWD",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).CWD(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DataDir(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DefaultPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DefaultPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/DefaultPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DefaultPrivateKey(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DefaultProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project_DefaultProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DefaultProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/DefaultProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DefaultProvider(ctx, req.(*Project_DefaultProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Home_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Home(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Home",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Home(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Host_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Host(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Host(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_LocalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).LocalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/LocalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).LocalData(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_PrimaryTargetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).PrimaryTargetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/PrimaryTargetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).PrimaryTargetName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ResourceId(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_RootPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).RootPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/RootPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).RootPath(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Target_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project_TargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Target(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Target",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Target(ctx, req.(*Project_TargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_TargetIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).TargetIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/TargetIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).TargetIds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_TargetIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).TargetIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/TargetIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).TargetIndex(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_TargetNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).TargetNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/TargetNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).TargetNames(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Tmp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Tmp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Tmp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Tmp(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).UI(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_VagrantfileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).VagrantfileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/VagrantfileName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).VagrantfileName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_VagrantfilePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).VagrantfilePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/VagrantfilePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).VagrantfilePath(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectService_ServiceDesc is the grpc.ServiceDesc for ProjectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProjectService",
	HandlerType: (*ProjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ActiveTargets",
			Handler:    _ProjectService_ActiveTargets_Handler,
		},
		{
			MethodName: "Boxes",
			Handler:    _ProjectService_Boxes_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _ProjectService_Config_Handler,
		},
		{
			MethodName: "CWD",
			Handler:    _ProjectService_CWD_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _ProjectService_DataDir_Handler,
		},
		{
			MethodName: "DefaultPrivateKey",
			Handler:    _ProjectService_DefaultPrivateKey_Handler,
		},
		{
			MethodName: "DefaultProvider",
			Handler:    _ProjectService_DefaultProvider_Handler,
		},
		{
			MethodName: "Home",
			Handler:    _ProjectService_Home_Handler,
		},
		{
			MethodName: "Host",
			Handler:    _ProjectService_Host_Handler,
		},
		{
			MethodName: "LocalData",
			Handler:    _ProjectService_LocalData_Handler,
		},
		{
			MethodName: "PrimaryTargetName",
			Handler:    _ProjectService_PrimaryTargetName_Handler,
		},
		{
			MethodName: "ResourceId",
			Handler:    _ProjectService_ResourceId_Handler,
		},
		{
			MethodName: "RootPath",
			Handler:    _ProjectService_RootPath_Handler,
		},
		{
			MethodName: "Target",
			Handler:    _ProjectService_Target_Handler,
		},
		{
			MethodName: "TargetIds",
			Handler:    _ProjectService_TargetIds_Handler,
		},
		{
			MethodName: "TargetIndex",
			Handler:    _ProjectService_TargetIndex_Handler,
		},
		{
			MethodName: "TargetNames",
			Handler:    _ProjectService_TargetNames_Handler,
		},
		{
			MethodName: "Tmp",
			Handler:    _ProjectService_Tmp_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _ProjectService_UI_Handler,
		},
		{
			MethodName: "VagrantfileName",
			Handler:    _ProjectService_VagrantfileName_Handler,
		},
		{
			MethodName: "VagrantfilePath",
			Handler:    _ProjectService_VagrantfilePath_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// VagrantfileServiceClient is the client API for VagrantfileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VagrantfileServiceClient interface {
	GetVagrantfile(ctx context.Context, in *Vagrantfile_GetVagrantfileRequest, opts ...grpc.CallOption) (*Vagrantfile_GetVagrantfileResponse, error)
	Target(ctx context.Context, in *Vagrantfile_TargetRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetResponse, error)
	TargetConfig(ctx context.Context, in *Vagrantfile_TargetConfigRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetConfigResponse, error)
	TargetNames(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Vagrantfile_TargetNamesResponse, error)
	PrimaryTargetName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Vagrantfile_PrimaryTargetNameResponse, error)
}

type vagrantfileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVagrantfileServiceClient(cc grpc.ClientConnInterface) VagrantfileServiceClient {
	return &vagrantfileServiceClient{cc}
}

func (c *vagrantfileServiceClient) GetVagrantfile(ctx context.Context, in *Vagrantfile_GetVagrantfileRequest, opts ...grpc.CallOption) (*Vagrantfile_GetVagrantfileResponse, error) {
	out := new(Vagrantfile_GetVagrantfileResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/GetVagrantfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) Target(ctx context.Context, in *Vagrantfile_TargetRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetResponse, error) {
	out := new(Vagrantfile_TargetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/Target", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) TargetConfig(ctx context.Context, in *Vagrantfile_TargetConfigRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetConfigResponse, error) {
	out := new(Vagrantfile_TargetConfigResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/TargetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) TargetNames(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Vagrantfile_TargetNamesResponse, error) {
	out := new(Vagrantfile_TargetNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/TargetNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) PrimaryTargetName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Vagrantfile_PrimaryTargetNameResponse, error) {
	out := new(Vagrantfile_PrimaryTargetNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/PrimaryTargetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VagrantfileServiceServer is the server API for VagrantfileService service.
// All implementations should embed UnimplementedVagrantfileServiceServer
// for forward compatibility
type VagrantfileServiceServer interface {
	GetVagrantfile(context.Context, *Vagrantfile_GetVagrantfileRequest) (*Vagrantfile_GetVagrantfileResponse, error)
	Target(context.Context, *Vagrantfile_TargetRequest) (*Vagrantfile_TargetResponse, error)
	TargetConfig(context.Context, *Vagrantfile_TargetConfigRequest) (*Vagrantfile_TargetConfigResponse, error)
	TargetNames(context.Context, *emptypb.Empty) (*Vagrantfile_TargetNamesResponse, error)
	PrimaryTargetName(context.Context, *emptypb.Empty) (*Vagrantfile_PrimaryTargetNameResponse, error)
}

// UnimplementedVagrantfileServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVagrantfileServiceServer struct {
}

func (UnimplementedVagrantfileServiceServer) GetVagrantfile(context.Context, *Vagrantfile_GetVagrantfileRequest) (*Vagrantfile_GetVagrantfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVagrantfile not implemented")
}
func (UnimplementedVagrantfileServiceServer) Target(context.Context, *Vagrantfile_TargetRequest) (*Vagrantfile_TargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Target not implemented")
}
func (UnimplementedVagrantfileServiceServer) TargetConfig(context.Context, *Vagrantfile_TargetConfigRequest) (*Vagrantfile_TargetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetConfig not implemented")
}
func (UnimplementedVagrantfileServiceServer) TargetNames(context.Context, *emptypb.Empty) (*Vagrantfile_TargetNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetNames not implemented")
}
func (UnimplementedVagrantfileServiceServer) PrimaryTargetName(context.Context, *emptypb.Empty) (*Vagrantfile_PrimaryTargetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrimaryTargetName not implemented")
}

// UnsafeVagrantfileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VagrantfileServiceServer will
// result in compilation errors.
type UnsafeVagrantfileServiceServer interface {
	mustEmbedUnimplementedVagrantfileServiceServer()
}

func RegisterVagrantfileServiceServer(s grpc.ServiceRegistrar, srv VagrantfileServiceServer) {
	s.RegisterService(&VagrantfileService_ServiceDesc, srv)
}

func _VagrantfileService_GetVagrantfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_GetVagrantfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).GetVagrantfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/GetVagrantfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).GetVagrantfile(ctx, req.(*Vagrantfile_GetVagrantfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_Target_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_TargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).Target(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/Target",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).Target(ctx, req.(*Vagrantfile_TargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_TargetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_TargetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).TargetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/TargetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).TargetConfig(ctx, req.(*Vagrantfile_TargetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_TargetNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).TargetNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/TargetNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).TargetNames(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_PrimaryTargetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).PrimaryTargetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/PrimaryTargetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).PrimaryTargetName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// VagrantfileService_ServiceDesc is the grpc.ServiceDesc for VagrantfileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VagrantfileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.VagrantfileService",
	HandlerType: (*VagrantfileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVagrantfile",
			Handler:    _VagrantfileService_GetVagrantfile_Handler,
		},
		{
			MethodName: "Target",
			Handler:    _VagrantfileService_Target_Handler,
		},
		{
			MethodName: "TargetConfig",
			Handler:    _VagrantfileService_TargetConfig_Handler,
		},
		{
			MethodName: "TargetNames",
			Handler:    _VagrantfileService_TargetNames_Handler,
		},
		{
			MethodName: "PrimaryTargetName",
			Handler:    _VagrantfileService_PrimaryTargetName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// TargetIndexServiceClient is the client API for TargetIndexService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetIndexServiceClient interface {
	Delete(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Get(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*Args_Target, error)
	Includes(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*TargetIndex_IncludesResponse, error)
	Set(ctx context.Context, in *Args_Target, opts ...grpc.CallOption) (*Args_Target, error)
	All(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TargetIndex_AllResponse, error)
}

type targetIndexServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetIndexServiceClient(cc grpc.ClientConnInterface) TargetIndexServiceClient {
	return &targetIndexServiceClient{cc}
}

func (c *targetIndexServiceClient) Delete(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetIndexService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetIndexServiceClient) Get(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*Args_Target, error) {
	out := new(Args_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetIndexService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetIndexServiceClient) Includes(ctx context.Context, in *TargetIndex_TargetIdentifier, opts ...grpc.CallOption) (*TargetIndex_IncludesResponse, error) {
	out := new(TargetIndex_IncludesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetIndexService/Includes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetIndexServiceClient) Set(ctx context.Context, in *Args_Target, opts ...grpc.CallOption) (*Args_Target, error) {
	out := new(Args_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetIndexService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetIndexServiceClient) All(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*TargetIndex_AllResponse, error) {
	out := new(TargetIndex_AllResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetIndexService/All", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetIndexServiceServer is the server API for TargetIndexService service.
// All implementations should embed UnimplementedTargetIndexServiceServer
// for forward compatibility
type TargetIndexServiceServer interface {
	Delete(context.Context, *TargetIndex_TargetIdentifier) (*emptypb.Empty, error)
	Get(context.Context, *TargetIndex_TargetIdentifier) (*Args_Target, error)
	Includes(context.Context, *TargetIndex_TargetIdentifier) (*TargetIndex_IncludesResponse, error)
	Set(context.Context, *Args_Target) (*Args_Target, error)
	All(context.Context, *emptypb.Empty) (*TargetIndex_AllResponse, error)
}

// UnimplementedTargetIndexServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTargetIndexServiceServer struct {
}

func (UnimplementedTargetIndexServiceServer) Delete(context.Context, *TargetIndex_TargetIdentifier) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetIndexServiceServer) Get(context.Context, *TargetIndex_TargetIdentifier) (*Args_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetIndexServiceServer) Includes(context.Context, *TargetIndex_TargetIdentifier) (*TargetIndex_IncludesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Includes not implemented")
}
func (UnimplementedTargetIndexServiceServer) Set(context.Context, *Args_Target) (*Args_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedTargetIndexServiceServer) All(context.Context, *emptypb.Empty) (*TargetIndex_AllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method All not implemented")
}

// UnsafeTargetIndexServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetIndexServiceServer will
// result in compilation errors.
type UnsafeTargetIndexServiceServer interface {
	mustEmbedUnimplementedTargetIndexServiceServer()
}

func RegisterTargetIndexServiceServer(s grpc.ServiceRegistrar, srv TargetIndexServiceServer) {
	s.RegisterService(&TargetIndexService_ServiceDesc, srv)
}

func _TargetIndexService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetIndex_TargetIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetIndexServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetIndexService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetIndexServiceServer).Delete(ctx, req.(*TargetIndex_TargetIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetIndexService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetIndex_TargetIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetIndexServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetIndexService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetIndexServiceServer).Get(ctx, req.(*TargetIndex_TargetIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetIndexService_Includes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetIndex_TargetIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetIndexServiceServer).Includes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetIndexService/Includes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetIndexServiceServer).Includes(ctx, req.(*TargetIndex_TargetIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetIndexService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Target)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetIndexServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetIndexService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetIndexServiceServer).Set(ctx, req.(*Args_Target))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetIndexService_All_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetIndexServiceServer).All(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetIndexService/All",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetIndexServiceServer).All(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetIndexService_ServiceDesc is the grpc.ServiceDesc for TargetIndexService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetIndexService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TargetIndexService",
	HandlerType: (*TargetIndexServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _TargetIndexService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetIndexService_Get_Handler,
		},
		{
			MethodName: "Includes",
			Handler:    _TargetIndexService_Includes_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _TargetIndexService_Set_Handler,
		},
		{
			MethodName: "All",
			Handler:    _TargetIndexService_All_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// BoxServiceClient is the client API for BoxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoxServiceClient interface {
	AutomaticUpdateCheckAllowed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_AutomaticUpdateCheckAllowedResponse, error)
	Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	HasUpdate(ctx context.Context, in *Box_HasUpdateRequest, opts ...grpc.CallOption) (*Box_HasUpdateResponse, error)
	UpdateInfo(ctx context.Context, in *Box_HasUpdateRequest, opts ...grpc.CallOption) (*Box_UpdateInfoResponse, error)
	InUse(ctx context.Context, in *Args_TargetIndex, opts ...grpc.CallOption) (*Box_InUseResponse, error)
	Machines(ctx context.Context, in *Args_TargetIndex, opts ...grpc.CallOption) (*Box_MachinesResponse, error)
	Repackage(ctx context.Context, in *Args_Path, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Directory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error)
	Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxMetadata, error)
	BoxMetadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_BoxMetadataResponse, error)
	MetadataURL(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_MetadataUrlResponse, error)
	Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_NameResponse, error)
	Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_ProviderResponse, error)
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_VersionResponse, error)
	Compare(ctx context.Context, in *Args_Box, opts ...grpc.CallOption) (*Box_EqualityResponse, error)
}

type boxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBoxServiceClient(cc grpc.ClientConnInterface) BoxServiceClient {
	return &boxServiceClient{cc}
}

func (c *boxServiceClient) AutomaticUpdateCheckAllowed(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_AutomaticUpdateCheckAllowedResponse, error) {
	out := new(Box_AutomaticUpdateCheckAllowedResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/AutomaticUpdateCheckAllowed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Destroy(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Destroy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) HasUpdate(ctx context.Context, in *Box_HasUpdateRequest, opts ...grpc.CallOption) (*Box_HasUpdateResponse, error) {
	out := new(Box_HasUpdateResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/HasUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) UpdateInfo(ctx context.Context, in *Box_HasUpdateRequest, opts ...grpc.CallOption) (*Box_UpdateInfoResponse, error) {
	out := new(Box_UpdateInfoResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/UpdateInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) InUse(ctx context.Context, in *Args_TargetIndex, opts ...grpc.CallOption) (*Box_InUseResponse, error) {
	out := new(Box_InUseResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/InUse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Machines(ctx context.Context, in *Args_TargetIndex, opts ...grpc.CallOption) (*Box_MachinesResponse, error) {
	out := new(Box_MachinesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Machines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Repackage(ctx context.Context, in *Args_Path, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Repackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Directory(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Path, error) {
	out := new(Args_Path)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Directory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Metadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_BoxMetadata, error) {
	out := new(Args_BoxMetadata)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Metadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) BoxMetadata(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_BoxMetadataResponse, error) {
	out := new(Box_BoxMetadataResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/BoxMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) MetadataURL(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_MetadataUrlResponse, error) {
	out := new(Box_MetadataUrlResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/MetadataURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Name(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_NameResponse, error) {
	out := new(Box_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Provider(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_ProviderResponse, error) {
	out := new(Box_ProviderResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Box_VersionResponse, error) {
	out := new(Box_VersionResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxServiceClient) Compare(ctx context.Context, in *Args_Box, opts ...grpc.CallOption) (*Box_EqualityResponse, error) {
	out := new(Box_EqualityResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxService/Compare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoxServiceServer is the server API for BoxService service.
// All implementations should embed UnimplementedBoxServiceServer
// for forward compatibility
type BoxServiceServer interface {
	AutomaticUpdateCheckAllowed(context.Context, *emptypb.Empty) (*Box_AutomaticUpdateCheckAllowedResponse, error)
	Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	HasUpdate(context.Context, *Box_HasUpdateRequest) (*Box_HasUpdateResponse, error)
	UpdateInfo(context.Context, *Box_HasUpdateRequest) (*Box_UpdateInfoResponse, error)
	InUse(context.Context, *Args_TargetIndex) (*Box_InUseResponse, error)
	Machines(context.Context, *Args_TargetIndex) (*Box_MachinesResponse, error)
	Repackage(context.Context, *Args_Path) (*emptypb.Empty, error)
	Directory(context.Context, *emptypb.Empty) (*Args_Path, error)
	Metadata(context.Context, *emptypb.Empty) (*Args_BoxMetadata, error)
	BoxMetadata(context.Context, *emptypb.Empty) (*Box_BoxMetadataResponse, error)
	MetadataURL(context.Context, *emptypb.Empty) (*Box_MetadataUrlResponse, error)
	Name(context.Context, *emptypb.Empty) (*Box_NameResponse, error)
	Provider(context.Context, *emptypb.Empty) (*Box_ProviderResponse, error)
	Version(context.Context, *emptypb.Empty) (*Box_VersionResponse, error)
	Compare(context.Context, *Args_Box) (*Box_EqualityResponse, error)
}

// UnimplementedBoxServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBoxServiceServer struct {
}

func (UnimplementedBoxServiceServer) AutomaticUpdateCheckAllowed(context.Context, *emptypb.Empty) (*Box_AutomaticUpdateCheckAllowedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutomaticUpdateCheckAllowed not implemented")
}
func (UnimplementedBoxServiceServer) Destroy(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedBoxServiceServer) HasUpdate(context.Context, *Box_HasUpdateRequest) (*Box_HasUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasUpdate not implemented")
}
func (UnimplementedBoxServiceServer) UpdateInfo(context.Context, *Box_HasUpdateRequest) (*Box_UpdateInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfo not implemented")
}
func (UnimplementedBoxServiceServer) InUse(context.Context, *Args_TargetIndex) (*Box_InUseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InUse not implemented")
}
func (UnimplementedBoxServiceServer) Machines(context.Context, *Args_TargetIndex) (*Box_MachinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Machines not implemented")
}
func (UnimplementedBoxServiceServer) Repackage(context.Context, *Args_Path) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Repackage not implemented")
}
func (UnimplementedBoxServiceServer) Directory(context.Context, *emptypb.Empty) (*Args_Path, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Directory not implemented")
}
func (UnimplementedBoxServiceServer) Metadata(context.Context, *emptypb.Empty) (*Args_BoxMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedBoxServiceServer) BoxMetadata(context.Context, *emptypb.Empty) (*Box_BoxMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoxMetadata not implemented")
}
func (UnimplementedBoxServiceServer) MetadataURL(context.Context, *emptypb.Empty) (*Box_MetadataUrlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MetadataURL not implemented")
}
func (UnimplementedBoxServiceServer) Name(context.Context, *emptypb.Empty) (*Box_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedBoxServiceServer) Provider(context.Context, *emptypb.Empty) (*Box_ProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedBoxServiceServer) Version(context.Context, *emptypb.Empty) (*Box_VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedBoxServiceServer) Compare(context.Context, *Args_Box) (*Box_EqualityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compare not implemented")
}

// UnsafeBoxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoxServiceServer will
// result in compilation errors.
type UnsafeBoxServiceServer interface {
	mustEmbedUnimplementedBoxServiceServer()
}

func RegisterBoxServiceServer(s grpc.ServiceRegistrar, srv BoxServiceServer) {
	s.RegisterService(&BoxService_ServiceDesc, srv)
}

func _BoxService_AutomaticUpdateCheckAllowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).AutomaticUpdateCheckAllowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/AutomaticUpdateCheckAllowed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).AutomaticUpdateCheckAllowed(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Destroy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Destroy(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_HasUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Box_HasUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).HasUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/HasUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).HasUpdate(ctx, req.(*Box_HasUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_UpdateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Box_HasUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).UpdateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/UpdateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).UpdateInfo(ctx, req.(*Box_HasUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_InUse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_TargetIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).InUse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/InUse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).InUse(ctx, req.(*Args_TargetIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Machines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_TargetIndex)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Machines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Machines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Machines(ctx, req.(*Args_TargetIndex))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Repackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Path)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Repackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Repackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Repackage(ctx, req.(*Args_Path))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Directory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Directory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Directory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Directory(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Metadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Metadata(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_BoxMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).BoxMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/BoxMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).BoxMetadata(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_MetadataURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).MetadataURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/MetadataURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).MetadataURL(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Name(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Provider(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxService_Compare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Box)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxServiceServer).Compare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxService/Compare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxServiceServer).Compare(ctx, req.(*Args_Box))
	}
	return interceptor(ctx, in, info, handler)
}

// BoxService_ServiceDesc is the grpc.ServiceDesc for BoxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.BoxService",
	HandlerType: (*BoxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutomaticUpdateCheckAllowed",
			Handler:    _BoxService_AutomaticUpdateCheckAllowed_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _BoxService_Destroy_Handler,
		},
		{
			MethodName: "HasUpdate",
			Handler:    _BoxService_HasUpdate_Handler,
		},
		{
			MethodName: "UpdateInfo",
			Handler:    _BoxService_UpdateInfo_Handler,
		},
		{
			MethodName: "InUse",
			Handler:    _BoxService_InUse_Handler,
		},
		{
			MethodName: "Machines",
			Handler:    _BoxService_Machines_Handler,
		},
		{
			MethodName: "Repackage",
			Handler:    _BoxService_Repackage_Handler,
		},
		{
			MethodName: "Directory",
			Handler:    _BoxService_Directory_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _BoxService_Metadata_Handler,
		},
		{
			MethodName: "BoxMetadata",
			Handler:    _BoxService_BoxMetadata_Handler,
		},
		{
			MethodName: "MetadataURL",
			Handler:    _BoxService_MetadataURL_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _BoxService_Name_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _BoxService_Provider_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _BoxService_Version_Handler,
		},
		{
			MethodName: "Compare",
			Handler:    _BoxService_Compare_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// BoxCollectionServiceClient is the client API for BoxCollectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoxCollectionServiceClient interface {
	Add(ctx context.Context, in *BoxCollection_AddRequest, opts ...grpc.CallOption) (*Args_Box, error)
	All(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BoxCollection_AllResponse, error)
	Clean(ctx context.Context, in *BoxCollection_CleanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Find(ctx context.Context, in *BoxCollection_FindRequest, opts ...grpc.CallOption) (*Args_Box, error)
}

type boxCollectionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBoxCollectionServiceClient(cc grpc.ClientConnInterface) BoxCollectionServiceClient {
	return &boxCollectionServiceClient{cc}
}

func (c *boxCollectionServiceClient) Add(ctx context.Context, in *BoxCollection_AddRequest, opts ...grpc.CallOption) (*Args_Box, error) {
	out := new(Args_Box)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxCollectionService/Add", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxCollectionServiceClient) All(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BoxCollection_AllResponse, error) {
	out := new(BoxCollection_AllResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxCollectionService/All", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxCollectionServiceClient) Clean(ctx context.Context, in *BoxCollection_CleanRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxCollectionService/Clean", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxCollectionServiceClient) Find(ctx context.Context, in *BoxCollection_FindRequest, opts ...grpc.CallOption) (*Args_Box, error) {
	out := new(Args_Box)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxCollectionService/Find", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoxCollectionServiceServer is the server API for BoxCollectionService service.
// All implementations should embed UnimplementedBoxCollectionServiceServer
// for forward compatibility
type BoxCollectionServiceServer interface {
	Add(context.Context, *BoxCollection_AddRequest) (*Args_Box, error)
	All(context.Context, *emptypb.Empty) (*BoxCollection_AllResponse, error)
	Clean(context.Context, *BoxCollection_CleanRequest) (*emptypb.Empty, error)
	Find(context.Context, *BoxCollection_FindRequest) (*Args_Box, error)
}

// UnimplementedBoxCollectionServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBoxCollectionServiceServer struct {
}

func (UnimplementedBoxCollectionServiceServer) Add(context.Context, *BoxCollection_AddRequest) (*Args_Box, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add not implemented")
}
func (UnimplementedBoxCollectionServiceServer) All(context.Context, *emptypb.Empty) (*BoxCollection_AllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method All not implemented")
}
func (UnimplementedBoxCollectionServiceServer) Clean(context.Context, *BoxCollection_CleanRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clean not implemented")
}
func (UnimplementedBoxCollectionServiceServer) Find(context.Context, *BoxCollection_FindRequest) (*Args_Box, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}

// UnsafeBoxCollectionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoxCollectionServiceServer will
// result in compilation errors.
type UnsafeBoxCollectionServiceServer interface {
	mustEmbedUnimplementedBoxCollectionServiceServer()
}

func RegisterBoxCollectionServiceServer(s grpc.ServiceRegistrar, srv BoxCollectionServiceServer) {
	s.RegisterService(&BoxCollectionService_ServiceDesc, srv)
}

func _BoxCollectionService_Add_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxCollection_AddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxCollectionServiceServer).Add(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxCollectionService/Add",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxCollectionServiceServer).Add(ctx, req.(*BoxCollection_AddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxCollectionService_All_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxCollectionServiceServer).All(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxCollectionService/All",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxCollectionServiceServer).All(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxCollectionService_Clean_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxCollection_CleanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxCollectionServiceServer).Clean(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxCollectionService/Clean",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxCollectionServiceServer).Clean(ctx, req.(*BoxCollection_CleanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxCollectionService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxCollection_FindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxCollectionServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxCollectionService/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxCollectionServiceServer).Find(ctx, req.(*BoxCollection_FindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BoxCollectionService_ServiceDesc is the grpc.ServiceDesc for BoxCollectionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoxCollectionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.BoxCollectionService",
	HandlerType: (*BoxCollectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add",
			Handler:    _BoxCollectionService_Add_Handler,
		},
		{
			MethodName: "All",
			Handler:    _BoxCollectionService_All_Handler,
		},
		{
			MethodName: "Clean",
			Handler:    _BoxCollectionService_Clean_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _BoxCollectionService_Find_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// BoxMetadataServiceClient is the client API for BoxMetadataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoxMetadataServiceClient interface {
	BoxName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BoxMetadata_NameResponse, error)
	LoadMetadata(ctx context.Context, in *BoxMetadata_LoadMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Version(ctx context.Context, in *BoxMetadata_VersionQuery, opts ...grpc.CallOption) (*BoxMetadata_VersionResponse, error)
	ListVersions(ctx context.Context, in *BoxMetadata_ListVersionsQuery, opts ...grpc.CallOption) (*BoxMetadata_ListVersionsResponse, error)
	Provider(ctx context.Context, in *BoxMetadata_ProviderRequest, opts ...grpc.CallOption) (*BoxMetadata_ProviderResponse, error)
	ListProviders(ctx context.Context, in *BoxMetadata_ListProvidersRequest, opts ...grpc.CallOption) (*BoxMetadata_ListProvidersResponse, error)
}

type boxMetadataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBoxMetadataServiceClient(cc grpc.ClientConnInterface) BoxMetadataServiceClient {
	return &boxMetadataServiceClient{cc}
}

func (c *boxMetadataServiceClient) BoxName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BoxMetadata_NameResponse, error) {
	out := new(BoxMetadata_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/BoxName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxMetadataServiceClient) LoadMetadata(ctx context.Context, in *BoxMetadata_LoadMetadataRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/LoadMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxMetadataServiceClient) Version(ctx context.Context, in *BoxMetadata_VersionQuery, opts ...grpc.CallOption) (*BoxMetadata_VersionResponse, error) {
	out := new(BoxMetadata_VersionResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxMetadataServiceClient) ListVersions(ctx context.Context, in *BoxMetadata_ListVersionsQuery, opts ...grpc.CallOption) (*BoxMetadata_ListVersionsResponse, error) {
	out := new(BoxMetadata_ListVersionsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/ListVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxMetadataServiceClient) Provider(ctx context.Context, in *BoxMetadata_ProviderRequest, opts ...grpc.CallOption) (*BoxMetadata_ProviderResponse, error) {
	out := new(BoxMetadata_ProviderResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boxMetadataServiceClient) ListProviders(ctx context.Context, in *BoxMetadata_ListProvidersRequest, opts ...grpc.CallOption) (*BoxMetadata_ListProvidersResponse, error) {
	out := new(BoxMetadata_ListProvidersResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BoxMetadataService/ListProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoxMetadataServiceServer is the server API for BoxMetadataService service.
// All implementations should embed UnimplementedBoxMetadataServiceServer
// for forward compatibility
type BoxMetadataServiceServer interface {
	BoxName(context.Context, *emptypb.Empty) (*BoxMetadata_NameResponse, error)
	LoadMetadata(context.Context, *BoxMetadata_LoadMetadataRequest) (*emptypb.Empty, error)
	Version(context.Context, *BoxMetadata_VersionQuery) (*BoxMetadata_VersionResponse, error)
	ListVersions(context.Context, *BoxMetadata_ListVersionsQuery) (*BoxMetadata_ListVersionsResponse, error)
	Provider(context.Context, *BoxMetadata_ProviderRequest) (*BoxMetadata_ProviderResponse, error)
	ListProviders(context.Context, *BoxMetadata_ListProvidersRequest) (*BoxMetadata_ListProvidersResponse, error)
}

// UnimplementedBoxMetadataServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBoxMetadataServiceServer struct {
}

func (UnimplementedBoxMetadataServiceServer) BoxName(context.Context, *emptypb.Empty) (*BoxMetadata_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoxName not implemented")
}
func (UnimplementedBoxMetadataServiceServer) LoadMetadata(context.Context, *BoxMetadata_LoadMetadataRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadMetadata not implemented")
}
func (UnimplementedBoxMetadataServiceServer) Version(context.Context, *BoxMetadata_VersionQuery) (*BoxMetadata_VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedBoxMetadataServiceServer) ListVersions(context.Context, *BoxMetadata_ListVersionsQuery) (*BoxMetadata_ListVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVersions not implemented")
}
func (UnimplementedBoxMetadataServiceServer) Provider(context.Context, *BoxMetadata_ProviderRequest) (*BoxMetadata_ProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedBoxMetadataServiceServer) ListProviders(context.Context, *BoxMetadata_ListProvidersRequest) (*BoxMetadata_ListProvidersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProviders not implemented")
}

// UnsafeBoxMetadataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoxMetadataServiceServer will
// result in compilation errors.
type UnsafeBoxMetadataServiceServer interface {
	mustEmbedUnimplementedBoxMetadataServiceServer()
}

func RegisterBoxMetadataServiceServer(s grpc.ServiceRegistrar, srv BoxMetadataServiceServer) {
	s.RegisterService(&BoxMetadataService_ServiceDesc, srv)
}

func _BoxMetadataService_BoxName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).BoxName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/BoxName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).BoxName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxMetadataService_LoadMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxMetadata_LoadMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).LoadMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/LoadMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).LoadMetadata(ctx, req.(*BoxMetadata_LoadMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxMetadataService_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxMetadata_VersionQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).Version(ctx, req.(*BoxMetadata_VersionQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxMetadataService_ListVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxMetadata_ListVersionsQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).ListVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/ListVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).ListVersions(ctx, req.(*BoxMetadata_ListVersionsQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxMetadataService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxMetadata_ProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).Provider(ctx, req.(*BoxMetadata_ProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BoxMetadataService_ListProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoxMetadata_ListProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoxMetadataServiceServer).ListProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BoxMetadataService/ListProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoxMetadataServiceServer).ListProviders(ctx, req.(*BoxMetadata_ListProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BoxMetadataService_ServiceDesc is the grpc.ServiceDesc for BoxMetadataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BoxMetadataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.BoxMetadataService",
	HandlerType: (*BoxMetadataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BoxName",
			Handler:    _BoxMetadataService_BoxName_Handler,
		},
		{
			MethodName: "LoadMetadata",
			Handler:    _BoxMetadataService_LoadMetadata_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _BoxMetadataService_Version_Handler,
		},
		{
			MethodName: "ListVersions",
			Handler:    _BoxMetadataService_ListVersions_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _BoxMetadataService_Provider_Handler,
		},
		{
			MethodName: "ListProviders",
			Handler:    _BoxMetadataService_ListProviders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// PushServiceClient is the client API for PushService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PushServiceClient interface {
	PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error)
	SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error)
}

type pushServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPushServiceClient(cc grpc.ClientConnInterface) PushServiceClient {
	return &pushServiceClient{cc}
}

func (c *pushServiceClient) PushSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/PushSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushServiceClient) Push(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/Push", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushServiceClient) Seed(ctx context.Context, in *Args_Seeds, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/Seed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushServiceClient) Seeds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Args_Seeds, error) {
	out := new(Args_Seeds)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/Seeds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushServiceClient) SetPluginName(ctx context.Context, in *PluginInfo_Name, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/SetPluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pushServiceClient) PluginName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PluginInfo_Name, error) {
	out := new(PluginInfo_Name)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PushService/PluginName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushServiceServer is the server API for PushService service.
// All implementations should embed UnimplementedPushServiceServer
// for forward compatibility
type PushServiceServer interface {
	PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error)
	Push(context.Context, *FuncSpec_Args) (*emptypb.Empty, error)
	Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error)
	Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error)
	SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error)
	PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error)
}

// UnimplementedPushServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPushServiceServer struct {
}

func (UnimplementedPushServiceServer) PushSpec(context.Context, *emptypb.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushSpec not implemented")
}
func (UnimplementedPushServiceServer) Push(context.Context, *FuncSpec_Args) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedPushServiceServer) Seed(context.Context, *Args_Seeds) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seed not implemented")
}
func (UnimplementedPushServiceServer) Seeds(context.Context, *emptypb.Empty) (*Args_Seeds, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seeds not implemented")
}
func (UnimplementedPushServiceServer) SetPluginName(context.Context, *PluginInfo_Name) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPluginName not implemented")
}
func (UnimplementedPushServiceServer) PluginName(context.Context, *emptypb.Empty) (*PluginInfo_Name, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PluginName not implemented")
}

// UnsafePushServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PushServiceServer will
// result in compilation errors.
type UnsafePushServiceServer interface {
	mustEmbedUnimplementedPushServiceServer()
}

func RegisterPushServiceServer(s grpc.ServiceRegistrar, srv PushServiceServer) {
	s.RegisterService(&PushService_ServiceDesc, srv)
}

func _PushService_PushSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).PushSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/PushSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).PushSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).Push(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushService_Seed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Args_Seeds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).Seed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/Seed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).Seed(ctx, req.(*Args_Seeds))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushService_Seeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).Seeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/Seeds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).Seeds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushService_SetPluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PluginInfo_Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).SetPluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/SetPluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).SetPluginName(ctx, req.(*PluginInfo_Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _PushService_PluginName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushServiceServer).PluginName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PushService/PluginName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushServiceServer).PluginName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PushService_ServiceDesc is the grpc.ServiceDesc for PushService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PushService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.PushService",
	HandlerType: (*PushServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushSpec",
			Handler:    _PushService_PushSpec_Handler,
		},
		{
			MethodName: "Push",
			Handler:    _PushService_Push_Handler,
		},
		{
			MethodName: "Seed",
			Handler:    _PushService_Seed_Handler,
		},
		{
			MethodName: "Seeds",
			Handler:    _PushService_Seeds_Handler,
		},
		{
			MethodName: "SetPluginName",
			Handler:    _PushService_SetPluginName_Handler,
		},
		{
			MethodName: "PluginName",
			Handler:    _PushService_PluginName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}
