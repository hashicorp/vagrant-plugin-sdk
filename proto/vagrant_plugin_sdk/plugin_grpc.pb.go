// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vagrant_plugin_sdk

import (
	context "context"
	any "github.com/golang/protobuf/ptypes/any"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// TerminalUIServiceClient is the client API for TerminalUIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TerminalUIServiceClient interface {
	Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error)
	IsInteractive(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error)
}

type terminalUIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalUIServiceClient(cc grpc.ClientConnInterface) TerminalUIServiceClient {
	return &terminalUIServiceClient{cc}
}

func (c *terminalUIServiceClient) Output(ctx context.Context, in *TerminalUI_OutputRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/Output", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalUIServiceClient) Events(ctx context.Context, opts ...grpc.CallOption) (TerminalUIService_EventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TerminalUIService_serviceDesc.Streams[0], "/hashicorp.vagrant.sdk.TerminalUIService/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalUIServiceEventsClient{stream}
	return x, nil
}

type TerminalUIService_EventsClient interface {
	Send(*TerminalUI_Event) error
	Recv() (*TerminalUI_Response, error)
	grpc.ClientStream
}

type terminalUIServiceEventsClient struct {
	grpc.ClientStream
}

func (x *terminalUIServiceEventsClient) Send(m *TerminalUI_Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalUIServiceEventsClient) Recv() (*TerminalUI_Response, error) {
	m := new(TerminalUI_Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalUIServiceClient) IsInteractive(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TerminalUI_IsInteractiveResponse, error) {
	out := new(TerminalUI_IsInteractiveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalUIServiceServer is the server API for TerminalUIService service.
// All implementations should embed UnimplementedTerminalUIServiceServer
// for forward compatibility
type TerminalUIServiceServer interface {
	Output(context.Context, *TerminalUI_OutputRequest) (*empty.Empty, error)
	Events(TerminalUIService_EventsServer) error
	IsInteractive(context.Context, *empty.Empty) (*TerminalUI_IsInteractiveResponse, error)
}

// UnimplementedTerminalUIServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTerminalUIServiceServer struct {
}

func (UnimplementedTerminalUIServiceServer) Output(context.Context, *TerminalUI_OutputRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Output not implemented")
}
func (UnimplementedTerminalUIServiceServer) Events(TerminalUIService_EventsServer) error {
	return status.Errorf(codes.Unimplemented, "method Events not implemented")
}
func (UnimplementedTerminalUIServiceServer) IsInteractive(context.Context, *empty.Empty) (*TerminalUI_IsInteractiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsInteractive not implemented")
}

// UnsafeTerminalUIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalUIServiceServer will
// result in compilation errors.
type UnsafeTerminalUIServiceServer interface {
	mustEmbedUnimplementedTerminalUIServiceServer()
}

func RegisterTerminalUIServiceServer(s grpc.ServiceRegistrar, srv TerminalUIServiceServer) {
	s.RegisterService(&_TerminalUIService_serviceDesc, srv)
}

func _TerminalUIService_Output_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminalUI_OutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).Output(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/Output",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).Output(ctx, req.(*TerminalUI_OutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalUIService_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalUIServiceServer).Events(&terminalUIServiceEventsServer{stream})
}

type TerminalUIService_EventsServer interface {
	Send(*TerminalUI_Response) error
	Recv() (*TerminalUI_Event, error)
	grpc.ServerStream
}

type terminalUIServiceEventsServer struct {
	grpc.ServerStream
}

func (x *terminalUIServiceEventsServer) Send(m *TerminalUI_Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalUIServiceEventsServer) Recv() (*TerminalUI_Event, error) {
	m := new(TerminalUI_Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TerminalUIService_IsInteractive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TerminalUIService/IsInteractive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalUIServiceServer).IsInteractive(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TerminalUIService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TerminalUIService",
	HandlerType: (*TerminalUIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Output",
			Handler:    _TerminalUIService_Output_Handler,
		},
		{
			MethodName: "IsInteractive",
			Handler:    _TerminalUIService_IsInteractive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Events",
			Handler:       _TerminalUIService_Events_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// MapperClient is the client API for Mapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapperClient interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error)
}

type mapperClient struct {
	cc grpc.ClientConnInterface
}

func NewMapperClient(cc grpc.ClientConnInterface) MapperClient {
	return &mapperClient{cc}
}

func (c *mapperClient) ListMappers(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Map_ListResponse, error) {
	out := new(Map_ListResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/ListMappers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapperClient) Map(ctx context.Context, in *Map_Request, opts ...grpc.CallOption) (*Map_Response, error) {
	out := new(Map_Response)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.Mapper/Map", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapperServer is the server API for Mapper service.
// All implementations should embed UnimplementedMapperServer
// for forward compatibility
type MapperServer interface {
	// ListMappers returns the list of mappers that this plugin supports.
	ListMappers(context.Context, *empty.Empty) (*Map_ListResponse, error)
	// Map executes a mapper.
	Map(context.Context, *Map_Request) (*Map_Response, error)
}

// UnimplementedMapperServer should be embedded to have forward compatible implementations.
type UnimplementedMapperServer struct {
}

func (UnimplementedMapperServer) ListMappers(context.Context, *empty.Empty) (*Map_ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappers not implemented")
}
func (UnimplementedMapperServer) Map(context.Context, *Map_Request) (*Map_Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Map not implemented")
}

// UnsafeMapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapperServer will
// result in compilation errors.
type UnsafeMapperServer interface {
	mustEmbedUnimplementedMapperServer()
}

func RegisterMapperServer(s grpc.ServiceRegistrar, srv MapperServer) {
	s.RegisterService(&_Mapper_serviceDesc, srv)
}

func _Mapper_ListMappers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).ListMappers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/ListMappers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).ListMappers(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mapper_Map_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Map_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapperServer).Map(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.Mapper/Map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapperServer).Map(ctx, req.(*Map_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Mapper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.Mapper",
	HandlerType: (*MapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMappers",
			Handler:    _Mapper_ListMappers_Handler,
		},
		{
			MethodName: "Map",
			Handler:    _Mapper_Map_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// StateBagServiceClient is the client API for StateBagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StateBagServiceClient interface {
	Get(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetResponse, error)
	GetOk(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetOkResponse, error)
	Put(ctx context.Context, in *StateBag_PutRequest, opts ...grpc.CallOption) (*StateBag_PutResponse, error)
	Remove(ctx context.Context, in *StateBag_RemoveRequest, opts ...grpc.CallOption) (*StateBag_RemoveResponse, error)
}

type stateBagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStateBagServiceClient(cc grpc.ClientConnInterface) StateBagServiceClient {
	return &stateBagServiceClient{cc}
}

func (c *stateBagServiceClient) Get(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetResponse, error) {
	out := new(StateBag_GetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) GetOk(ctx context.Context, in *StateBag_GetRequest, opts ...grpc.CallOption) (*StateBag_GetOkResponse, error) {
	out := new(StateBag_GetOkResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/GetOk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) Put(ctx context.Context, in *StateBag_PutRequest, opts ...grpc.CallOption) (*StateBag_PutResponse, error) {
	out := new(StateBag_PutResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateBagServiceClient) Remove(ctx context.Context, in *StateBag_RemoveRequest, opts ...grpc.CallOption) (*StateBag_RemoveResponse, error) {
	out := new(StateBag_RemoveResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.StateBagService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateBagServiceServer is the server API for StateBagService service.
// All implementations should embed UnimplementedStateBagServiceServer
// for forward compatibility
type StateBagServiceServer interface {
	Get(context.Context, *StateBag_GetRequest) (*StateBag_GetResponse, error)
	GetOk(context.Context, *StateBag_GetRequest) (*StateBag_GetOkResponse, error)
	Put(context.Context, *StateBag_PutRequest) (*StateBag_PutResponse, error)
	Remove(context.Context, *StateBag_RemoveRequest) (*StateBag_RemoveResponse, error)
}

// UnimplementedStateBagServiceServer should be embedded to have forward compatible implementations.
type UnimplementedStateBagServiceServer struct {
}

func (UnimplementedStateBagServiceServer) Get(context.Context, *StateBag_GetRequest) (*StateBag_GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStateBagServiceServer) GetOk(context.Context, *StateBag_GetRequest) (*StateBag_GetOkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOk not implemented")
}
func (UnimplementedStateBagServiceServer) Put(context.Context, *StateBag_PutRequest) (*StateBag_PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedStateBagServiceServer) Remove(context.Context, *StateBag_RemoveRequest) (*StateBag_RemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}

// UnsafeStateBagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StateBagServiceServer will
// result in compilation errors.
type UnsafeStateBagServiceServer interface {
	mustEmbedUnimplementedStateBagServiceServer()
}

func RegisterStateBagServiceServer(s grpc.ServiceRegistrar, srv StateBagServiceServer) {
	s.RegisterService(&_StateBagService_serviceDesc, srv)
}

func _StateBagService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Get(ctx, req.(*StateBag_GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_GetOk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).GetOk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/GetOk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).GetOk(ctx, req.(*StateBag_GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Put(ctx, req.(*StateBag_PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StateBagService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateBag_RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateBagServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.StateBagService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateBagServiceServer).Remove(ctx, req.(*StateBag_RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _StateBagService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.StateBagService",
	HandlerType: (*StateBagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _StateBagService_Get_Handler,
		},
		{
			MethodName: "GetOk",
			Handler:    _StateBagService_GetOk_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _StateBagService_Put_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _StateBagService_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// PluginInfoServiceClient is the client API for PluginInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginInfoServiceClient interface {
	ComponentTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentList, error)
}

type pluginInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginInfoServiceClient(cc grpc.ClientConnInterface) PluginInfoServiceClient {
	return &pluginInfoServiceClient{cc}
}

func (c *pluginInfoServiceClient) ComponentTypes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PluginInfo_ComponentList, error) {
	out := new(PluginInfo_ComponentList)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.PluginInfoService/ComponentTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginInfoServiceServer is the server API for PluginInfoService service.
// All implementations should embed UnimplementedPluginInfoServiceServer
// for forward compatibility
type PluginInfoServiceServer interface {
	ComponentTypes(context.Context, *empty.Empty) (*PluginInfo_ComponentList, error)
}

// UnimplementedPluginInfoServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPluginInfoServiceServer struct {
}

func (UnimplementedPluginInfoServiceServer) ComponentTypes(context.Context, *empty.Empty) (*PluginInfo_ComponentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComponentTypes not implemented")
}

// UnsafePluginInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginInfoServiceServer will
// result in compilation errors.
type UnsafePluginInfoServiceServer interface {
	mustEmbedUnimplementedPluginInfoServiceServer()
}

func RegisterPluginInfoServiceServer(s grpc.ServiceRegistrar, srv PluginInfoServiceServer) {
	s.RegisterService(&_PluginInfoService_serviceDesc, srv)
}

func _PluginInfoService_ComponentTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginInfoServiceServer).ComponentTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.PluginInfoService/ComponentTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginInfoServiceServer).ComponentTypes(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _PluginInfoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.PluginInfoService",
	HandlerType: (*PluginInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ComponentTypes",
			Handler:    _PluginInfoService_ComponentTypes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProviderServiceClient is the client API for ProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProviderServiceClient interface {
	// rpc Usable(google.protobuf.Empty) returns (Provider.UsableResp);
	// rpc Installed(google.protobuf.Empty) returns (Provider.InstalledResp);
	Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error)
	UsableSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error)
	InstalledSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*empty.Empty, error)
	InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ActionUp(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_ActionResp, error)
	ActionUpSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type providerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProviderServiceClient(cc grpc.ClientConnInterface) ProviderServiceClient {
	return &providerServiceClient{cc}
}

func (c *providerServiceClient) Usable(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_UsableResp, error) {
	out := new(Provider_UsableResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Usable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) UsableSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/UsableSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Installed(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_InstalledResp, error) {
	out := new(Provider_InstalledResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Installed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) InstalledSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/InitSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ActionUp(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Provider_ActionResp, error) {
	out := new(Provider_ActionResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ActionUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ActionUpSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ActionUpSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProviderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProviderServiceServer is the server API for ProviderService service.
// All implementations should embed UnimplementedProviderServiceServer
// for forward compatibility
type ProviderServiceServer interface {
	// rpc Usable(google.protobuf.Empty) returns (Provider.UsableResp);
	// rpc Installed(google.protobuf.Empty) returns (Provider.InstalledResp);
	Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error)
	UsableSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error)
	InstalledSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Init(context.Context, *FuncSpec_Args) (*empty.Empty, error)
	InitSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	ActionUp(context.Context, *FuncSpec_Args) (*Provider_ActionResp, error)
	ActionUpSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
}

// UnimplementedProviderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProviderServiceServer struct {
}

func (UnimplementedProviderServiceServer) Usable(context.Context, *FuncSpec_Args) (*Provider_UsableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Usable not implemented")
}
func (UnimplementedProviderServiceServer) UsableSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsableSpec not implemented")
}
func (UnimplementedProviderServiceServer) Installed(context.Context, *FuncSpec_Args) (*Provider_InstalledResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Installed not implemented")
}
func (UnimplementedProviderServiceServer) InstalledSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstalledSpec not implemented")
}
func (UnimplementedProviderServiceServer) Init(context.Context, *FuncSpec_Args) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedProviderServiceServer) InitSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitSpec not implemented")
}
func (UnimplementedProviderServiceServer) ActionUp(context.Context, *FuncSpec_Args) (*Provider_ActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionUp not implemented")
}
func (UnimplementedProviderServiceServer) ActionUpSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionUpSpec not implemented")
}
func (UnimplementedProviderServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedProviderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProviderServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}

// UnsafeProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProviderServiceServer will
// result in compilation errors.
type UnsafeProviderServiceServer interface {
	mustEmbedUnimplementedProviderServiceServer()
}

func RegisterProviderServiceServer(s grpc.ServiceRegistrar, srv ProviderServiceServer) {
	s.RegisterService(&_ProviderService_serviceDesc, srv)
}

func _ProviderService_Usable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Usable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Usable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Usable(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_UsableSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).UsableSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/UsableSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).UsableSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Installed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Installed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Installed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Installed(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_InstalledSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/InstalledSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).InstalledSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Init(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_InitSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).InitSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/InitSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).InitSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ActionUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ActionUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ActionUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ActionUp(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ActionUpSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ActionUpSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ActionUpSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ActionUpSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProviderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProviderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProviderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProviderService",
	HandlerType: (*ProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Usable",
			Handler:    _ProviderService_Usable_Handler,
		},
		{
			MethodName: "UsableSpec",
			Handler:    _ProviderService_UsableSpec_Handler,
		},
		{
			MethodName: "Installed",
			Handler:    _ProviderService_Installed_Handler,
		},
		{
			MethodName: "InstalledSpec",
			Handler:    _ProviderService_InstalledSpec_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _ProviderService_Init_Handler,
		},
		{
			MethodName: "InitSpec",
			Handler:    _ProviderService_InitSpec_Handler,
		},
		{
			MethodName: "ActionUp",
			Handler:    _ProviderService_ActionUp_Handler,
		},
		{
			MethodName: "ActionUpSpec",
			Handler:    _ProviderService_ActionUpSpec_Handler,
		},
		{
			MethodName: "ConfigStruct",
			Handler:    _ProviderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProviderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ProviderService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProvisionerServiceClient is the client API for ProvisionerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProvisionerServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type provisionerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProvisionerServiceClient(cc grpc.ClientConnInterface) ProvisionerServiceClient {
	return &provisionerServiceClient{cc}
}

func (c *provisionerServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionerServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProvisionerService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProvisionerServiceServer is the server API for ProvisionerService service.
// All implementations should embed UnimplementedProvisionerServiceServer
// for forward compatibility
type ProvisionerServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
}

// UnimplementedProvisionerServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProvisionerServiceServer struct {
}

func (UnimplementedProvisionerServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedProvisionerServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedProvisionerServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}

// UnsafeProvisionerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProvisionerServiceServer will
// result in compilation errors.
type UnsafeProvisionerServiceServer interface {
	mustEmbedUnimplementedProvisionerServiceServer()
}

func RegisterProvisionerServiceServer(s grpc.ServiceRegistrar, srv ProvisionerServiceServer) {
	s.RegisterService(&_ProvisionerService_serviceDesc, srv)
}

func _ProvisionerService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionerService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionerServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProvisionerService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionerServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProvisionerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProvisionerService",
	HandlerType: (*ProvisionerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ProvisionerService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ProvisionerService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ProvisionerService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommandServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error)
	CommandInfoSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ExecuteSpec(ctx context.Context, in *Command_ExecuteSpecReq, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Execute(ctx context.Context, in *Command_ExecuteReq, opts ...grpc.CallOption) (*Command_ExecuteResp, error) {
	out := new(Command_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfoSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) CommandInfo(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Command_CommandInfoResp, error) {
	out := new(Command_CommandInfoResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommandService/CommandInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
// All implementations should embed UnimplementedCommandServiceServer
// for forward compatibility
type CommandServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error)
	Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error)
	CommandInfoSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error)
}

// UnimplementedCommandServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCommandServiceServer struct {
}

func (UnimplementedCommandServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommandServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommandServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommandServiceServer) ExecuteSpec(context.Context, *Command_ExecuteSpecReq) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommandServiceServer) Execute(context.Context, *Command_ExecuteReq) (*Command_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfoSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfoSpec not implemented")
}
func (UnimplementedCommandServiceServer) CommandInfo(context.Context, *FuncSpec_Args) (*Command_CommandInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommandInfo not implemented")
}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	s.RegisterService(&_CommandService_serviceDesc, srv)
}

func _CommandService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteSpecReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ExecuteSpec(ctx, req.(*Command_ExecuteSpecReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command_ExecuteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Execute(ctx, req.(*Command_ExecuteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfoSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfoSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfoSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_CommandInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CommandInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommandService/CommandInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CommandInfo(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommandService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommandService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommandService_Documentation_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommandService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommandService_Execute_Handler,
		},
		{
			MethodName: "CommandInfoSpec",
			Handler:    _CommandService_CommandInfoSpec_Handler,
		},
		{
			MethodName: "CommandInfo",
			Handler:    _CommandService_CommandInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// CommunicatorServiceClient is the client API for CommunicatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommunicatorServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	MatchSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error)
	InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_InitResp, error)
	ReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	WaitForReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error)
	DownloadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error)
	UploadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error)
	ExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error)
	TestSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error)
	ResetSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ResetResp, error)
}

type communicatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommunicatorServiceClient(cc grpc.ClientConnInterface) CommunicatorServiceClient {
	return &communicatorServiceClient{cc}
}

func (c *communicatorServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) MatchSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Match(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_MatchResp, error) {
	out := new(Communicator_MatchResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Match", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) InitSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Init(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_InitResp, error) {
	out := new(Communicator_InitResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Ready(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Ready", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReadySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) WaitForReady(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ReadyResp, error) {
	out := new(Communicator_ReadyResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) DownloadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Download(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error) {
	out := new(Communicator_FileTransferResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Download", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) UploadSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Upload(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_FileTransferResp, error) {
	out := new(Communicator_FileTransferResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Upload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Execute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecuteSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) PrivilegedExecute(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ExecuteResp, error) {
	out := new(Communicator_ExecuteResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) TestSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Test(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_TestResp, error) {
	out := new(Communicator_TestResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) ResetSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communicatorServiceClient) Reset(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Communicator_ResetResp, error) {
	out := new(Communicator_ResetResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.CommunicatorService/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommunicatorServiceServer is the server API for CommunicatorService service.
// All implementations should embed UnimplementedCommunicatorServiceServer
// for forward compatibility
type CommunicatorServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	MatchSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error)
	InitSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Init(context.Context, *FuncSpec_Args) (*Communicator_InitResp, error)
	ReadySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	WaitForReadySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error)
	DownloadSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Download(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error)
	UploadSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Upload(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error)
	ExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	PrivilegedExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error)
	TestSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error)
	ResetSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Reset(context.Context, *FuncSpec_Args) (*Communicator_ResetResp, error)
}

// UnimplementedCommunicatorServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCommunicatorServiceServer struct {
}

func (UnimplementedCommunicatorServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedCommunicatorServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCommunicatorServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedCommunicatorServiceServer) MatchSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Match(context.Context, *FuncSpec_Args) (*Communicator_MatchResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Match not implemented")
}
func (UnimplementedCommunicatorServiceServer) InitSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Init(context.Context, *FuncSpec_Args) (*Communicator_InitResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedCommunicatorServiceServer) ReadySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Ready(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ready not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReadySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReadySpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) WaitForReady(context.Context, *FuncSpec_Args) (*Communicator_ReadyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForReady not implemented")
}
func (UnimplementedCommunicatorServiceServer) DownloadSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Download(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Download not implemented")
}
func (UnimplementedCommunicatorServiceServer) UploadSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Upload(context.Context, *FuncSpec_Args) (*Communicator_FileTransferResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedCommunicatorServiceServer) ExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Execute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecuteSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecuteSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) PrivilegedExecute(context.Context, *FuncSpec_Args) (*Communicator_ExecuteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecute not implemented")
}
func (UnimplementedCommunicatorServiceServer) TestSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Test(context.Context, *FuncSpec_Args) (*Communicator_TestResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedCommunicatorServiceServer) ResetSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSpec not implemented")
}
func (UnimplementedCommunicatorServiceServer) Reset(context.Context, *FuncSpec_Args) (*Communicator_ResetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}

// UnsafeCommunicatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommunicatorServiceServer will
// result in compilation errors.
type UnsafeCommunicatorServiceServer interface {
	mustEmbedUnimplementedCommunicatorServiceServer()
}

func RegisterCommunicatorServiceServer(s grpc.ServiceRegistrar, srv CommunicatorServiceServer) {
	s.RegisterService(&_CommunicatorService_serviceDesc, srv)
}

func _CommunicatorService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_MatchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/MatchSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).MatchSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Match_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Match(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Match",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Match(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_InitSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/InitSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).InitSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Init(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ReadySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Ready_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Ready(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Ready",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Ready(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReadySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReadySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReadySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_WaitForReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/WaitForReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).WaitForReady(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_DownloadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/DownloadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).DownloadSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Download(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_UploadSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/UploadSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).UploadSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Upload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Upload(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ExecuteSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Execute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecuteSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecuteSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecuteSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_PrivilegedExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/PrivilegedExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).PrivilegedExecute(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_TestSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/TestSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).TestSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Test(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_ResetSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/ResetSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).ResetSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunicatorService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunicatorServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.CommunicatorService/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunicatorServiceServer).Reset(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommunicatorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.CommunicatorService",
	HandlerType: (*CommunicatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _CommunicatorService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _CommunicatorService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _CommunicatorService_Documentation_Handler,
		},
		{
			MethodName: "MatchSpec",
			Handler:    _CommunicatorService_MatchSpec_Handler,
		},
		{
			MethodName: "Match",
			Handler:    _CommunicatorService_Match_Handler,
		},
		{
			MethodName: "InitSpec",
			Handler:    _CommunicatorService_InitSpec_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _CommunicatorService_Init_Handler,
		},
		{
			MethodName: "ReadySpec",
			Handler:    _CommunicatorService_ReadySpec_Handler,
		},
		{
			MethodName: "Ready",
			Handler:    _CommunicatorService_Ready_Handler,
		},
		{
			MethodName: "WaitForReadySpec",
			Handler:    _CommunicatorService_WaitForReadySpec_Handler,
		},
		{
			MethodName: "WaitForReady",
			Handler:    _CommunicatorService_WaitForReady_Handler,
		},
		{
			MethodName: "DownloadSpec",
			Handler:    _CommunicatorService_DownloadSpec_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _CommunicatorService_Download_Handler,
		},
		{
			MethodName: "UploadSpec",
			Handler:    _CommunicatorService_UploadSpec_Handler,
		},
		{
			MethodName: "Upload",
			Handler:    _CommunicatorService_Upload_Handler,
		},
		{
			MethodName: "ExecuteSpec",
			Handler:    _CommunicatorService_ExecuteSpec_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommunicatorService_Execute_Handler,
		},
		{
			MethodName: "PrivilegedExecuteSpec",
			Handler:    _CommunicatorService_PrivilegedExecuteSpec_Handler,
		},
		{
			MethodName: "PrivilegedExecute",
			Handler:    _CommunicatorService_PrivilegedExecute_Handler,
		},
		{
			MethodName: "TestSpec",
			Handler:    _CommunicatorService_TestSpec_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _CommunicatorService_Test_Handler,
		},
		{
			MethodName: "ResetSpec",
			Handler:    _CommunicatorService_ResetSpec_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _CommunicatorService_Reset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ConfigServiceClient is the client API for ConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type configServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigServiceClient(cc grpc.ClientConnInterface) ConfigServiceClient {
	return &configServiceClient{cc}
}

func (c *configServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ConfigService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigServiceServer is the server API for ConfigService service.
// All implementations should embed UnimplementedConfigServiceServer
// for forward compatibility
type ConfigServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
}

// UnimplementedConfigServiceServer should be embedded to have forward compatible implementations.
type UnimplementedConfigServiceServer struct {
}

func (UnimplementedConfigServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedConfigServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedConfigServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}

// UnsafeConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigServiceServer will
// result in compilation errors.
type UnsafeConfigServiceServer interface {
	mustEmbedUnimplementedConfigServiceServer()
}

func RegisterConfigServiceServer(s grpc.ServiceRegistrar, srv ConfigServiceServer) {
	s.RegisterService(&_ConfigService_serviceDesc, srv)
}

func _ConfigService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ConfigService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConfigService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ConfigService",
	HandlerType: (*ConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _ConfigService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _ConfigService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _ConfigService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// HostServiceClient is the client API for HostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error)
	DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Parents(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentsResp, error)
	ParentsSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
}

type hostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostServiceClient(cc grpc.ClientConnInterface) HostServiceClient {
	return &hostServiceClient{cc}
}

func (c *hostServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error) {
	out := new(Platform_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) Parents(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentsResp, error) {
	out := new(Platform_ParentsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/Parents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostServiceClient) ParentsSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.HostService/ParentsSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostServiceServer is the server API for HostService service.
// All implementations should embed UnimplementedHostServiceServer
// for forward compatibility
type HostServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error)
	DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Parents(context.Context, *FuncSpec_Args) (*Platform_ParentsResp, error)
	ParentsSpec(context.Context, *empty.Empty) (*FuncSpec, error)
}

// UnimplementedHostServiceServer should be embedded to have forward compatible implementations.
type UnimplementedHostServiceServer struct {
}

func (UnimplementedHostServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedHostServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedHostServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedHostServiceServer) Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedHostServiceServer) DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedHostServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedHostServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedHostServiceServer) HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedHostServiceServer) Parents(context.Context, *FuncSpec_Args) (*Platform_ParentsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parents not implemented")
}
func (UnimplementedHostServiceServer) ParentsSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParentsSpec not implemented")
}

// UnsafeHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostServiceServer will
// result in compilation errors.
type UnsafeHostServiceServer interface {
	mustEmbedUnimplementedHostServiceServer()
}

func RegisterHostServiceServer(s grpc.ServiceRegistrar, srv HostServiceServer) {
	s.RegisterService(&_HostService_serviceDesc, srv)
}

func _HostService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).DetectSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).HasCapabilitySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_Parents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).Parents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/Parents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).Parents(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostService_ParentsSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostServiceServer).ParentsSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.HostService/ParentsSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostServiceServer).ParentsSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _HostService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.HostService",
	HandlerType: (*HostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _HostService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _HostService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _HostService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _HostService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _HostService_DetectSpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _HostService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _HostService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _HostService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _HostService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Parents",
			Handler:    _HostService_Parents_Handler,
		},
		{
			MethodName: "ParentsSpec",
			Handler:    _HostService_ParentsSpec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// GuestServiceClient is the client API for GuestService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
	Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error)
	DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error)
	CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error)
	HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
	Parents(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentsResp, error)
	ParentsSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error)
}

type guestServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestServiceClient(cc grpc.ClientConnInterface) GuestServiceClient {
	return &guestServiceClient{cc}
}

func (c *guestServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Detect(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_DetectResp, error) {
	out := new(Platform_DetectResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) DetectSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/DetectSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Capability(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*Platform_Capability_Resp, error) {
	out := new(Platform_Capability_Resp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Capability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) CapabilitySpec(ctx context.Context, in *Platform_Capability_NamedRequest, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapability(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_Capability_CheckResp, error) {
	out := new(Platform_Capability_CheckResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) HasCapabilitySpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) Parents(ctx context.Context, in *FuncSpec_Args, opts ...grpc.CallOption) (*Platform_ParentsResp, error) {
	out := new(Platform_ParentsResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/Parents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestServiceClient) ParentsSpec(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FuncSpec, error) {
	out := new(FuncSpec)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.GuestService/ParentsSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestServiceServer is the server API for GuestService service.
// All implementations should embed UnimplementedGuestServiceServer
// for forward compatibility
type GuestServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
	Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error)
	DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error)
	CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error)
	HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error)
	HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error)
	Parents(context.Context, *FuncSpec_Args) (*Platform_ParentsResp, error)
	ParentsSpec(context.Context, *empty.Empty) (*FuncSpec, error)
}

// UnimplementedGuestServiceServer should be embedded to have forward compatible implementations.
type UnimplementedGuestServiceServer struct {
}

func (UnimplementedGuestServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedGuestServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedGuestServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}
func (UnimplementedGuestServiceServer) Detect(context.Context, *FuncSpec_Args) (*Platform_DetectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedGuestServiceServer) DetectSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectSpec not implemented")
}
func (UnimplementedGuestServiceServer) Capability(context.Context, *Platform_Capability_NamedRequest) (*Platform_Capability_Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capability not implemented")
}
func (UnimplementedGuestServiceServer) CapabilitySpec(context.Context, *Platform_Capability_NamedRequest) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) HasCapability(context.Context, *FuncSpec_Args) (*Platform_Capability_CheckResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapability not implemented")
}
func (UnimplementedGuestServiceServer) HasCapabilitySpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCapabilitySpec not implemented")
}
func (UnimplementedGuestServiceServer) Parents(context.Context, *FuncSpec_Args) (*Platform_ParentsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parents not implemented")
}
func (UnimplementedGuestServiceServer) ParentsSpec(context.Context, *empty.Empty) (*FuncSpec, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParentsSpec not implemented")
}

// UnsafeGuestServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestServiceServer will
// result in compilation errors.
type UnsafeGuestServiceServer interface {
	mustEmbedUnimplementedGuestServiceServer()
}

func RegisterGuestServiceServer(s grpc.ServiceRegistrar, srv GuestServiceServer) {
	s.RegisterService(&_GuestService_serviceDesc, srv)
}

func _GuestService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Detect(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_DetectSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).DetectSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/DetectSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).DetectSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Capability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Capability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Capability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Capability(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_CapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Platform_Capability_NamedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/CapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).CapabilitySpec(ctx, req.(*Platform_Capability_NamedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapability(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_HasCapabilitySpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/HasCapabilitySpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).HasCapabilitySpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_Parents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FuncSpec_Args)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).Parents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/Parents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).Parents(ctx, req.(*FuncSpec_Args))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestService_ParentsSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServiceServer).ParentsSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.GuestService/ParentsSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServiceServer).ParentsSpec(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _GuestService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.GuestService",
	HandlerType: (*GuestServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _GuestService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _GuestService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _GuestService_Documentation_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _GuestService_Detect_Handler,
		},
		{
			MethodName: "DetectSpec",
			Handler:    _GuestService_DetectSpec_Handler,
		},
		{
			MethodName: "Capability",
			Handler:    _GuestService_Capability_Handler,
		},
		{
			MethodName: "CapabilitySpec",
			Handler:    _GuestService_CapabilitySpec_Handler,
		},
		{
			MethodName: "HasCapability",
			Handler:    _GuestService_HasCapability_Handler,
		},
		{
			MethodName: "HasCapabilitySpec",
			Handler:    _GuestService_HasCapabilitySpec_Handler,
		},
		{
			MethodName: "Parents",
			Handler:    _GuestService_Parents_Handler,
		},
		{
			MethodName: "ParentsSpec",
			Handler:    _GuestService_ParentsSpec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// SyncedFolderServiceClient is the client API for SyncedFolderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncedFolderServiceClient interface {
	ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error)
	Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error)
}

type syncedFolderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncedFolderServiceClient(cc grpc.ClientConnInterface) SyncedFolderServiceClient {
	return &syncedFolderServiceClient{cc}
}

func (c *syncedFolderServiceClient) ConfigStruct(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_StructResp, error) {
	out := new(Config_StructResp)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Configure(ctx context.Context, in *Config_ConfigureRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncedFolderServiceClient) Documentation(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Config_Documentation, error) {
	out := new(Config_Documentation)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncedFolderServiceServer is the server API for SyncedFolderService service.
// All implementations should embed UnimplementedSyncedFolderServiceServer
// for forward compatibility
type SyncedFolderServiceServer interface {
	ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error)
	Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error)
	Documentation(context.Context, *empty.Empty) (*Config_Documentation, error)
}

// UnimplementedSyncedFolderServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSyncedFolderServiceServer struct {
}

func (UnimplementedSyncedFolderServiceServer) ConfigStruct(context.Context, *empty.Empty) (*Config_StructResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigStruct not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Configure(context.Context, *Config_ConfigureRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedSyncedFolderServiceServer) Documentation(context.Context, *empty.Empty) (*Config_Documentation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documentation not implemented")
}

// UnsafeSyncedFolderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncedFolderServiceServer will
// result in compilation errors.
type UnsafeSyncedFolderServiceServer interface {
	mustEmbedUnimplementedSyncedFolderServiceServer()
}

func RegisterSyncedFolderServiceServer(s grpc.ServiceRegistrar, srv SyncedFolderServiceServer) {
	s.RegisterService(&_SyncedFolderService_serviceDesc, srv)
}

func _SyncedFolderService_ConfigStruct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/ConfigStruct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).ConfigStruct(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config_ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Configure(ctx, req.(*Config_ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncedFolderService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.SyncedFolderService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncedFolderServiceServer).Documentation(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _SyncedFolderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.SyncedFolderService",
	HandlerType: (*SyncedFolderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConfigStruct",
			Handler:    _SyncedFolderService_ConfigStruct_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _SyncedFolderService_Configure_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _SyncedFolderService_Documentation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// BasisServiceClient is the client API for BasisService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BasisServiceClient interface {
	DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Basis, error)
	UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Host(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Host, error)
}

type basisServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBasisServiceClient(cc grpc.ClientConnInterface) BasisServiceClient {
	return &basisServiceClient{cc}
}

func (c *basisServiceClient) DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Basis, error) {
	out := new(Args_DataDir_Basis)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *basisServiceClient) Host(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Host, error) {
	out := new(Args_Host)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.BasisService/Host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BasisServiceServer is the server API for BasisService service.
// All implementations should embed UnimplementedBasisServiceServer
// for forward compatibility
type BasisServiceServer interface {
	DataDir(context.Context, *empty.Empty) (*Args_DataDir_Basis, error)
	UI(context.Context, *empty.Empty) (*Args_TerminalUI, error)
	Host(context.Context, *empty.Empty) (*Args_Host, error)
}

// UnimplementedBasisServiceServer should be embedded to have forward compatible implementations.
type UnimplementedBasisServiceServer struct {
}

func (UnimplementedBasisServiceServer) DataDir(context.Context, *empty.Empty) (*Args_DataDir_Basis, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedBasisServiceServer) UI(context.Context, *empty.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedBasisServiceServer) Host(context.Context, *empty.Empty) (*Args_Host, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Host not implemented")
}

// UnsafeBasisServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BasisServiceServer will
// result in compilation errors.
type UnsafeBasisServiceServer interface {
	mustEmbedUnimplementedBasisServiceServer()
}

func RegisterBasisServiceServer(s grpc.ServiceRegistrar, srv BasisServiceServer) {
	s.RegisterService(&_BasisService_serviceDesc, srv)
}

func _BasisService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).DataDir(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).UI(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BasisService_Host_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BasisServiceServer).Host(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.BasisService/Host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BasisServiceServer).Host(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _BasisService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.BasisService",
	HandlerType: (*BasisServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DataDir",
			Handler:    _BasisService_DataDir_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _BasisService_UI_Handler,
		},
		{
			MethodName: "Host",
			Handler:    _BasisService_Host_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// TargetServiceClient is the client API for TargetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetServiceClient interface {
	ResourceId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error)
	Record(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error)
	Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Project(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Project, error)
	Metadata(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error)
	DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error)
	State(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_State, error)
	UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Specialize(ctx context.Context, in *any.Any, opts ...grpc.CallOption) (*any.Any, error)
	Provider(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Provider, error)
	VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfileNameResponse, error)
	VagrantfilePath(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfilePathResponse, error)
	UpdatedAt(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error)
	Communicate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Communicator, error)
}

type targetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetServiceClient(cc grpc.ClientConnInterface) TargetServiceClient {
	return &targetServiceClient{cc}
}

func (c *targetServiceClient) ResourceId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error) {
	out := new(Target_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Record(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error) {
	out := new(Target_RecordResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/SetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Project(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Project, error) {
	out := new(Args_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Metadata(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error) {
	out := new(Args_MetadataSet)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Metadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error) {
	out := new(Args_DataDir_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) State(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_State, error) {
	out := new(Args_Target_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/State", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Specialize(ctx context.Context, in *any.Any, opts ...grpc.CallOption) (*any.Any, error) {
	out := new(any.Any)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Specialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Provider(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Provider, error) {
	out := new(Args_Provider)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfileNameResponse, error) {
	out := new(Target_VagrantfileNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/VagrantfileName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) VagrantfilePath(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfilePathResponse, error) {
	out := new(Target_VagrantfilePathResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/VagrantfilePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) UpdatedAt(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error) {
	out := new(Target_UpdatedAtResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/UpdatedAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetServiceClient) Communicate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Communicator, error) {
	out := new(Args_Communicator)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetService/Communicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetServiceServer is the server API for TargetService service.
// All implementations should embed UnimplementedTargetServiceServer
// for forward compatibility
type TargetServiceServer interface {
	ResourceId(context.Context, *empty.Empty) (*Target_ResourceIdResponse, error)
	Record(context.Context, *empty.Empty) (*Target_RecordResponse, error)
	Name(context.Context, *empty.Empty) (*Target_NameResponse, error)
	SetName(context.Context, *Target_SetNameRequest) (*empty.Empty, error)
	Project(context.Context, *empty.Empty) (*Args_Project, error)
	Metadata(context.Context, *empty.Empty) (*Args_MetadataSet, error)
	DataDir(context.Context, *empty.Empty) (*Args_DataDir_Target, error)
	State(context.Context, *empty.Empty) (*Args_Target_State, error)
	UI(context.Context, *empty.Empty) (*Args_TerminalUI, error)
	Specialize(context.Context, *any.Any) (*any.Any, error)
	Provider(context.Context, *empty.Empty) (*Args_Provider, error)
	VagrantfileName(context.Context, *empty.Empty) (*Target_VagrantfileNameResponse, error)
	VagrantfilePath(context.Context, *empty.Empty) (*Target_VagrantfilePathResponse, error)
	UpdatedAt(context.Context, *empty.Empty) (*Target_UpdatedAtResponse, error)
	Communicate(context.Context, *empty.Empty) (*Args_Communicator, error)
}

// UnimplementedTargetServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTargetServiceServer struct {
}

func (UnimplementedTargetServiceServer) ResourceId(context.Context, *empty.Empty) (*Target_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedTargetServiceServer) Record(context.Context, *empty.Empty) (*Target_RecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedTargetServiceServer) Name(context.Context, *empty.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedTargetServiceServer) SetName(context.Context, *Target_SetNameRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedTargetServiceServer) Project(context.Context, *empty.Empty) (*Args_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (UnimplementedTargetServiceServer) Metadata(context.Context, *empty.Empty) (*Args_MetadataSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedTargetServiceServer) DataDir(context.Context, *empty.Empty) (*Args_DataDir_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedTargetServiceServer) State(context.Context, *empty.Empty) (*Args_Target_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedTargetServiceServer) UI(context.Context, *empty.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedTargetServiceServer) Specialize(context.Context, *any.Any) (*any.Any, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Specialize not implemented")
}
func (UnimplementedTargetServiceServer) Provider(context.Context, *empty.Empty) (*Args_Provider, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedTargetServiceServer) VagrantfileName(context.Context, *empty.Empty) (*Target_VagrantfileNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfileName not implemented")
}
func (UnimplementedTargetServiceServer) VagrantfilePath(context.Context, *empty.Empty) (*Target_VagrantfilePathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfilePath not implemented")
}
func (UnimplementedTargetServiceServer) UpdatedAt(context.Context, *empty.Empty) (*Target_UpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatedAt not implemented")
}
func (UnimplementedTargetServiceServer) Communicate(context.Context, *empty.Empty) (*Args_Communicator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Communicate not implemented")
}

// UnsafeTargetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetServiceServer will
// result in compilation errors.
type UnsafeTargetServiceServer interface {
	mustEmbedUnimplementedTargetServiceServer()
}

func RegisterTargetServiceServer(s grpc.ServiceRegistrar, srv TargetServiceServer) {
	s.RegisterService(&_TargetService_serviceDesc, srv)
}

func _TargetService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).ResourceId(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Record(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Name(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/SetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).SetName(ctx, req.(*Target_SetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Project(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Metadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Metadata(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).DataDir(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/State",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).State(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).UI(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Specialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(any.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Specialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Specialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Specialize(ctx, req.(*any.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Provider(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_VagrantfileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).VagrantfileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/VagrantfileName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).VagrantfileName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_VagrantfilePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).VagrantfilePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/VagrantfilePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).VagrantfilePath(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_UpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).UpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/UpdatedAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).UpdatedAt(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetService_Communicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetServiceServer).Communicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetService/Communicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetServiceServer).Communicate(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TargetService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TargetService",
	HandlerType: (*TargetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResourceId",
			Handler:    _TargetService_ResourceId_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _TargetService_Record_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _TargetService_Name_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _TargetService_SetName_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _TargetService_Project_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _TargetService_Metadata_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _TargetService_DataDir_Handler,
		},
		{
			MethodName: "State",
			Handler:    _TargetService_State_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _TargetService_UI_Handler,
		},
		{
			MethodName: "Specialize",
			Handler:    _TargetService_Specialize_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _TargetService_Provider_Handler,
		},
		{
			MethodName: "VagrantfileName",
			Handler:    _TargetService_VagrantfileName_Handler,
		},
		{
			MethodName: "VagrantfilePath",
			Handler:    _TargetService_VagrantfilePath_Handler,
		},
		{
			MethodName: "UpdatedAt",
			Handler:    _TargetService_UpdatedAt_Handler,
		},
		{
			MethodName: "Communicate",
			Handler:    _TargetService_Communicate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// TargetMachineServiceClient is the client API for TargetMachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetMachineServiceClient interface {
	// Required so a machine can properly act as a target
	ResourceId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error)
	Record(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error)
	Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error)
	SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Project(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Project, error)
	Metadata(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error)
	DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error)
	State(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_State, error)
	UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Specialize(ctx context.Context, in *any.Any, opts ...grpc.CallOption) (*any.Any, error)
	Provider(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Provider, error)
	VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfileNameResponse, error)
	VagrantfilePath(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfilePathResponse, error)
	UpdatedAt(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error)
	Communicate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Communicator, error)
	// Machine specific
	SetID(ctx context.Context, in *Target_Machine_SetIDRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_GetIDResponse, error)
	SetState(ctx context.Context, in *Target_Machine_SetStateRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_State, error)
	SetUUID(ctx context.Context, in *Target_Machine_SetUUIDRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	GetUUID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_GetUUIDResponse, error)
	Box(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_Box, error)
	Guest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Guest, error)
	Reload(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	ConnectionInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_ConnectionInfoResponse, error)
	UID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_UIDResponse, error)
	SyncedFolders(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_SyncedFoldersResponse, error)
}

type targetMachineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetMachineServiceClient(cc grpc.ClientConnInterface) TargetMachineServiceClient {
	return &targetMachineServiceClient{cc}
}

func (c *targetMachineServiceClient) ResourceId(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_ResourceIdResponse, error) {
	out := new(Target_ResourceIdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/ResourceId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Record(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_RecordResponse, error) {
	out := new(Target_RecordResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Record", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Name(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_NameResponse, error) {
	out := new(Target_NameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetName(ctx context.Context, in *Target_SetNameRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Project(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Project, error) {
	out := new(Args_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Project", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Metadata(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MetadataSet, error) {
	out := new(Args_MetadataSet)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Metadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Target, error) {
	out := new(Args_DataDir_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) State(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_State, error) {
	out := new(Args_Target_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/State", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Specialize(ctx context.Context, in *any.Any, opts ...grpc.CallOption) (*any.Any, error) {
	out := new(any.Any)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Specialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Provider(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Provider, error) {
	out := new(Args_Provider)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Provider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfileNameResponse, error) {
	out := new(Target_VagrantfileNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/VagrantfileName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) VagrantfilePath(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_VagrantfilePathResponse, error) {
	out := new(Target_VagrantfilePathResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/VagrantfilePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UpdatedAt(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_UpdatedAtResponse, error) {
	out := new(Target_UpdatedAtResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UpdatedAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Communicate(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Communicator, error) {
	out := new(Args_Communicator)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Communicate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetID(ctx context.Context, in *Target_Machine_SetIDRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_GetIDResponse, error) {
	out := new(Target_Machine_GetIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetState(ctx context.Context, in *Target_Machine_SetStateRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_State, error) {
	out := new(Args_Target_Machine_State)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SetUUID(ctx context.Context, in *Target_Machine_SetUUIDRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) GetUUID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_GetUUIDResponse, error) {
	out := new(Target_Machine_GetUUIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/GetUUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Box(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Target_Machine_Box, error) {
	out := new(Args_Target_Machine_Box)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Box", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Guest(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Guest, error) {
	out := new(Args_Guest)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Guest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) Reload(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/Reload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) ConnectionInfo(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_ConnectionInfoResponse, error) {
	out := new(Target_Machine_ConnectionInfoResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/ConnectionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) UID(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_UIDResponse, error) {
	out := new(Target_Machine_UIDResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/UID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetMachineServiceClient) SyncedFolders(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Target_Machine_SyncedFoldersResponse, error) {
	out := new(Target_Machine_SyncedFoldersResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.TargetMachineService/SyncedFolders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetMachineServiceServer is the server API for TargetMachineService service.
// All implementations should embed UnimplementedTargetMachineServiceServer
// for forward compatibility
type TargetMachineServiceServer interface {
	// Required so a machine can properly act as a target
	ResourceId(context.Context, *empty.Empty) (*Target_ResourceIdResponse, error)
	Record(context.Context, *empty.Empty) (*Target_RecordResponse, error)
	Name(context.Context, *empty.Empty) (*Target_NameResponse, error)
	SetName(context.Context, *Target_SetNameRequest) (*empty.Empty, error)
	Project(context.Context, *empty.Empty) (*Args_Project, error)
	Metadata(context.Context, *empty.Empty) (*Args_MetadataSet, error)
	DataDir(context.Context, *empty.Empty) (*Args_DataDir_Target, error)
	State(context.Context, *empty.Empty) (*Args_Target_State, error)
	UI(context.Context, *empty.Empty) (*Args_TerminalUI, error)
	Specialize(context.Context, *any.Any) (*any.Any, error)
	Provider(context.Context, *empty.Empty) (*Args_Provider, error)
	VagrantfileName(context.Context, *empty.Empty) (*Target_VagrantfileNameResponse, error)
	VagrantfilePath(context.Context, *empty.Empty) (*Target_VagrantfilePathResponse, error)
	UpdatedAt(context.Context, *empty.Empty) (*Target_UpdatedAtResponse, error)
	Communicate(context.Context, *empty.Empty) (*Args_Communicator, error)
	// Machine specific
	SetID(context.Context, *Target_Machine_SetIDRequest) (*empty.Empty, error)
	GetID(context.Context, *empty.Empty) (*Target_Machine_GetIDResponse, error)
	SetState(context.Context, *Target_Machine_SetStateRequest) (*empty.Empty, error)
	GetState(context.Context, *empty.Empty) (*Args_Target_Machine_State, error)
	SetUUID(context.Context, *Target_Machine_SetUUIDRequest) (*empty.Empty, error)
	GetUUID(context.Context, *empty.Empty) (*Target_Machine_GetUUIDResponse, error)
	Box(context.Context, *empty.Empty) (*Args_Target_Machine_Box, error)
	Guest(context.Context, *empty.Empty) (*Args_Guest, error)
	Reload(context.Context, *empty.Empty) (*empty.Empty, error)
	ConnectionInfo(context.Context, *empty.Empty) (*Target_Machine_ConnectionInfoResponse, error)
	UID(context.Context, *empty.Empty) (*Target_Machine_UIDResponse, error)
	SyncedFolders(context.Context, *empty.Empty) (*Target_Machine_SyncedFoldersResponse, error)
}

// UnimplementedTargetMachineServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTargetMachineServiceServer struct {
}

func (UnimplementedTargetMachineServiceServer) ResourceId(context.Context, *empty.Empty) (*Target_ResourceIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceId not implemented")
}
func (UnimplementedTargetMachineServiceServer) Record(context.Context, *empty.Empty) (*Target_RecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Record not implemented")
}
func (UnimplementedTargetMachineServiceServer) Name(context.Context, *empty.Empty) (*Target_NameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetName(context.Context, *Target_SetNameRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedTargetMachineServiceServer) Project(context.Context, *empty.Empty) (*Args_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Project not implemented")
}
func (UnimplementedTargetMachineServiceServer) Metadata(context.Context, *empty.Empty) (*Args_MetadataSet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metadata not implemented")
}
func (UnimplementedTargetMachineServiceServer) DataDir(context.Context, *empty.Empty) (*Args_DataDir_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedTargetMachineServiceServer) State(context.Context, *empty.Empty) (*Args_Target_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method State not implemented")
}
func (UnimplementedTargetMachineServiceServer) UI(context.Context, *empty.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedTargetMachineServiceServer) Specialize(context.Context, *any.Any) (*any.Any, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Specialize not implemented")
}
func (UnimplementedTargetMachineServiceServer) Provider(context.Context, *empty.Empty) (*Args_Provider, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Provider not implemented")
}
func (UnimplementedTargetMachineServiceServer) VagrantfileName(context.Context, *empty.Empty) (*Target_VagrantfileNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfileName not implemented")
}
func (UnimplementedTargetMachineServiceServer) VagrantfilePath(context.Context, *empty.Empty) (*Target_VagrantfilePathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfilePath not implemented")
}
func (UnimplementedTargetMachineServiceServer) UpdatedAt(context.Context, *empty.Empty) (*Target_UpdatedAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatedAt not implemented")
}
func (UnimplementedTargetMachineServiceServer) Communicate(context.Context, *empty.Empty) (*Args_Communicator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Communicate not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetID(context.Context, *Target_Machine_SetIDRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetID not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetID(context.Context, *empty.Empty) (*Target_Machine_GetIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetID not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetState(context.Context, *Target_Machine_SetStateRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetState not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetState(context.Context, *empty.Empty) (*Args_Target_Machine_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedTargetMachineServiceServer) SetUUID(context.Context, *Target_Machine_SetUUIDRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUUID not implemented")
}
func (UnimplementedTargetMachineServiceServer) GetUUID(context.Context, *empty.Empty) (*Target_Machine_GetUUIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUUID not implemented")
}
func (UnimplementedTargetMachineServiceServer) Box(context.Context, *empty.Empty) (*Args_Target_Machine_Box, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Box not implemented")
}
func (UnimplementedTargetMachineServiceServer) Guest(context.Context, *empty.Empty) (*Args_Guest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Guest not implemented")
}
func (UnimplementedTargetMachineServiceServer) Reload(context.Context, *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reload not implemented")
}
func (UnimplementedTargetMachineServiceServer) ConnectionInfo(context.Context, *empty.Empty) (*Target_Machine_ConnectionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectionInfo not implemented")
}
func (UnimplementedTargetMachineServiceServer) UID(context.Context, *empty.Empty) (*Target_Machine_UIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UID not implemented")
}
func (UnimplementedTargetMachineServiceServer) SyncedFolders(context.Context, *empty.Empty) (*Target_Machine_SyncedFoldersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncedFolders not implemented")
}

// UnsafeTargetMachineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetMachineServiceServer will
// result in compilation errors.
type UnsafeTargetMachineServiceServer interface {
	mustEmbedUnimplementedTargetMachineServiceServer()
}

func RegisterTargetMachineServiceServer(s grpc.ServiceRegistrar, srv TargetMachineServiceServer) {
	s.RegisterService(&_TargetMachineService_serviceDesc, srv)
}

func _TargetMachineService_ResourceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).ResourceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/ResourceId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).ResourceId(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Record_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Record(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Record",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Record(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Name(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_SetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetName(ctx, req.(*Target_SetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Project_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Project(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Project",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Project(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Metadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Metadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Metadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Metadata(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).DataDir(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_State_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).State(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/State",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).State(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UI(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Specialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(any.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Specialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Specialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Specialize(ctx, req.(*any.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Provider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Provider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Provider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Provider(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_VagrantfileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).VagrantfileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/VagrantfileName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).VagrantfileName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_VagrantfilePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).VagrantfilePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/VagrantfilePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).VagrantfilePath(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UpdatedAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UpdatedAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UpdatedAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UpdatedAt(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Communicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Communicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Communicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Communicate(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_Machine_SetIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetID(ctx, req.(*Target_Machine_SetIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetID(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_Machine_SetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetState(ctx, req.(*Target_Machine_SetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetState(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Target_Machine_SetUUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SetUUID(ctx, req.(*Target_Machine_SetUUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_GetUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).GetUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/GetUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).GetUUID(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Box_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Box(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Box",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Box(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Guest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Guest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Guest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Guest(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_Reload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).Reload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/Reload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).Reload(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_ConnectionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).ConnectionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/ConnectionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).ConnectionInfo(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_UID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).UID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/UID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).UID(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetMachineService_SyncedFolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetMachineServiceServer).SyncedFolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.TargetMachineService/SyncedFolders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetMachineServiceServer).SyncedFolders(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TargetMachineService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.TargetMachineService",
	HandlerType: (*TargetMachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResourceId",
			Handler:    _TargetMachineService_ResourceId_Handler,
		},
		{
			MethodName: "Record",
			Handler:    _TargetMachineService_Record_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _TargetMachineService_Name_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _TargetMachineService_SetName_Handler,
		},
		{
			MethodName: "Project",
			Handler:    _TargetMachineService_Project_Handler,
		},
		{
			MethodName: "Metadata",
			Handler:    _TargetMachineService_Metadata_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _TargetMachineService_DataDir_Handler,
		},
		{
			MethodName: "State",
			Handler:    _TargetMachineService_State_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _TargetMachineService_UI_Handler,
		},
		{
			MethodName: "Specialize",
			Handler:    _TargetMachineService_Specialize_Handler,
		},
		{
			MethodName: "Provider",
			Handler:    _TargetMachineService_Provider_Handler,
		},
		{
			MethodName: "VagrantfileName",
			Handler:    _TargetMachineService_VagrantfileName_Handler,
		},
		{
			MethodName: "VagrantfilePath",
			Handler:    _TargetMachineService_VagrantfilePath_Handler,
		},
		{
			MethodName: "UpdatedAt",
			Handler:    _TargetMachineService_UpdatedAt_Handler,
		},
		{
			MethodName: "Communicate",
			Handler:    _TargetMachineService_Communicate_Handler,
		},
		{
			MethodName: "SetID",
			Handler:    _TargetMachineService_SetID_Handler,
		},
		{
			MethodName: "GetID",
			Handler:    _TargetMachineService_GetID_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _TargetMachineService_SetState_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _TargetMachineService_GetState_Handler,
		},
		{
			MethodName: "SetUUID",
			Handler:    _TargetMachineService_SetUUID_Handler,
		},
		{
			MethodName: "GetUUID",
			Handler:    _TargetMachineService_GetUUID_Handler,
		},
		{
			MethodName: "Box",
			Handler:    _TargetMachineService_Box_Handler,
		},
		{
			MethodName: "Guest",
			Handler:    _TargetMachineService_Guest_Handler,
		},
		{
			MethodName: "Reload",
			Handler:    _TargetMachineService_Reload_Handler,
		},
		{
			MethodName: "ConnectionInfo",
			Handler:    _TargetMachineService_ConnectionInfo_Handler,
		},
		{
			MethodName: "UID",
			Handler:    _TargetMachineService_UID_Handler,
		},
		{
			MethodName: "SyncedFolders",
			Handler:    _TargetMachineService_SyncedFolders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// ProjectServiceClient is the client API for ProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectServiceClient interface {
	MachineNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_MachineNamesResponse, error)
	MachineIndex(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MachineIndex, error)
	// rpc ActiveMachines(google.protobuf.Empty) returns (Project.ActiveMachinesResponse);
	CWD(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_CwdResponse, error)
	DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Project, error)
	VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_VagrantfileNameResponse, error)
	UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error)
	Home(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_HomeResponse, error)
	LocalData(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_LocalDataResponse, error)
	Tmp(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TmpResponse, error)
	DefaultPrivateKey(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_DefaultPrivateKeyResponse, error)
	Host(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Host, error)
	Target(ctx context.Context, in *Project_TargetRequest, opts ...grpc.CallOption) (*Args_Target, error)
	TargetNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TargetNamesResponse, error)
	TargetIds(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TargetIdsResponse, error)
}

type projectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {
	return &projectServiceClient{cc}
}

func (c *projectServiceClient) MachineNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_MachineNamesResponse, error) {
	out := new(Project_MachineNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/MachineNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) MachineIndex(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_MachineIndex, error) {
	out := new(Args_MachineIndex)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/MachineIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) CWD(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_CwdResponse, error) {
	out := new(Project_CwdResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/CWD", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DataDir(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_DataDir_Project, error) {
	out := new(Args_DataDir_Project)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/DataDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) VagrantfileName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_VagrantfileNameResponse, error) {
	out := new(Project_VagrantfileNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/VagrantfileName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) UI(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_TerminalUI, error) {
	out := new(Args_TerminalUI)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/UI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Home(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_HomeResponse, error) {
	out := new(Project_HomeResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Home", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) LocalData(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_LocalDataResponse, error) {
	out := new(Project_LocalDataResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/LocalData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Tmp(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TmpResponse, error) {
	out := new(Project_TmpResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Tmp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DefaultPrivateKey(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_DefaultPrivateKeyResponse, error) {
	out := new(Project_DefaultPrivateKeyResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/DefaultPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Host(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Args_Host, error) {
	out := new(Args_Host)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Target(ctx context.Context, in *Project_TargetRequest, opts ...grpc.CallOption) (*Args_Target, error) {
	out := new(Args_Target)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/Target", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) TargetNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TargetNamesResponse, error) {
	out := new(Project_TargetNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/TargetNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) TargetIds(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Project_TargetIdsResponse, error) {
	out := new(Project_TargetIdsResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.ProjectService/TargetIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectServiceServer is the server API for ProjectService service.
// All implementations should embed UnimplementedProjectServiceServer
// for forward compatibility
type ProjectServiceServer interface {
	MachineNames(context.Context, *empty.Empty) (*Project_MachineNamesResponse, error)
	MachineIndex(context.Context, *empty.Empty) (*Args_MachineIndex, error)
	// rpc ActiveMachines(google.protobuf.Empty) returns (Project.ActiveMachinesResponse);
	CWD(context.Context, *empty.Empty) (*Project_CwdResponse, error)
	DataDir(context.Context, *empty.Empty) (*Args_DataDir_Project, error)
	VagrantfileName(context.Context, *empty.Empty) (*Project_VagrantfileNameResponse, error)
	UI(context.Context, *empty.Empty) (*Args_TerminalUI, error)
	Home(context.Context, *empty.Empty) (*Project_HomeResponse, error)
	LocalData(context.Context, *empty.Empty) (*Project_LocalDataResponse, error)
	Tmp(context.Context, *empty.Empty) (*Project_TmpResponse, error)
	DefaultPrivateKey(context.Context, *empty.Empty) (*Project_DefaultPrivateKeyResponse, error)
	Host(context.Context, *empty.Empty) (*Args_Host, error)
	Target(context.Context, *Project_TargetRequest) (*Args_Target, error)
	TargetNames(context.Context, *empty.Empty) (*Project_TargetNamesResponse, error)
	TargetIds(context.Context, *empty.Empty) (*Project_TargetIdsResponse, error)
}

// UnimplementedProjectServiceServer should be embedded to have forward compatible implementations.
type UnimplementedProjectServiceServer struct {
}

func (UnimplementedProjectServiceServer) MachineNames(context.Context, *empty.Empty) (*Project_MachineNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MachineNames not implemented")
}
func (UnimplementedProjectServiceServer) MachineIndex(context.Context, *empty.Empty) (*Args_MachineIndex, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MachineIndex not implemented")
}
func (UnimplementedProjectServiceServer) CWD(context.Context, *empty.Empty) (*Project_CwdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CWD not implemented")
}
func (UnimplementedProjectServiceServer) DataDir(context.Context, *empty.Empty) (*Args_DataDir_Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DataDir not implemented")
}
func (UnimplementedProjectServiceServer) VagrantfileName(context.Context, *empty.Empty) (*Project_VagrantfileNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VagrantfileName not implemented")
}
func (UnimplementedProjectServiceServer) UI(context.Context, *empty.Empty) (*Args_TerminalUI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UI not implemented")
}
func (UnimplementedProjectServiceServer) Home(context.Context, *empty.Empty) (*Project_HomeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Home not implemented")
}
func (UnimplementedProjectServiceServer) LocalData(context.Context, *empty.Empty) (*Project_LocalDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalData not implemented")
}
func (UnimplementedProjectServiceServer) Tmp(context.Context, *empty.Empty) (*Project_TmpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tmp not implemented")
}
func (UnimplementedProjectServiceServer) DefaultPrivateKey(context.Context, *empty.Empty) (*Project_DefaultPrivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DefaultPrivateKey not implemented")
}
func (UnimplementedProjectServiceServer) Host(context.Context, *empty.Empty) (*Args_Host, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Host not implemented")
}
func (UnimplementedProjectServiceServer) Target(context.Context, *Project_TargetRequest) (*Args_Target, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Target not implemented")
}
func (UnimplementedProjectServiceServer) TargetNames(context.Context, *empty.Empty) (*Project_TargetNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetNames not implemented")
}
func (UnimplementedProjectServiceServer) TargetIds(context.Context, *empty.Empty) (*Project_TargetIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetIds not implemented")
}

// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectServiceServer will
// result in compilation errors.
type UnsafeProjectServiceServer interface {
	mustEmbedUnimplementedProjectServiceServer()
}

func RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {
	s.RegisterService(&_ProjectService_serviceDesc, srv)
}

func _ProjectService_MachineNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).MachineNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/MachineNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).MachineNames(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_MachineIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).MachineIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/MachineIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).MachineIndex(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_CWD_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).CWD(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/CWD",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).CWD(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DataDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DataDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/DataDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DataDir(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_VagrantfileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).VagrantfileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/VagrantfileName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).VagrantfileName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_UI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).UI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/UI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).UI(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Home_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Home(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Home",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Home(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_LocalData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).LocalData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/LocalData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).LocalData(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Tmp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Tmp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Tmp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Tmp(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DefaultPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DefaultPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/DefaultPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DefaultPrivateKey(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Host_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Host(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Host(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Target_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project_TargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Target(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/Target",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Target(ctx, req.(*Project_TargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_TargetNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).TargetNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/TargetNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).TargetNames(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_TargetIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).TargetIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.ProjectService/TargetIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).TargetIds(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProjectService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.ProjectService",
	HandlerType: (*ProjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MachineNames",
			Handler:    _ProjectService_MachineNames_Handler,
		},
		{
			MethodName: "MachineIndex",
			Handler:    _ProjectService_MachineIndex_Handler,
		},
		{
			MethodName: "CWD",
			Handler:    _ProjectService_CWD_Handler,
		},
		{
			MethodName: "DataDir",
			Handler:    _ProjectService_DataDir_Handler,
		},
		{
			MethodName: "VagrantfileName",
			Handler:    _ProjectService_VagrantfileName_Handler,
		},
		{
			MethodName: "UI",
			Handler:    _ProjectService_UI_Handler,
		},
		{
			MethodName: "Home",
			Handler:    _ProjectService_Home_Handler,
		},
		{
			MethodName: "LocalData",
			Handler:    _ProjectService_LocalData_Handler,
		},
		{
			MethodName: "Tmp",
			Handler:    _ProjectService_Tmp_Handler,
		},
		{
			MethodName: "DefaultPrivateKey",
			Handler:    _ProjectService_DefaultPrivateKey_Handler,
		},
		{
			MethodName: "Host",
			Handler:    _ProjectService_Host_Handler,
		},
		{
			MethodName: "Target",
			Handler:    _ProjectService_Target_Handler,
		},
		{
			MethodName: "TargetNames",
			Handler:    _ProjectService_TargetNames_Handler,
		},
		{
			MethodName: "TargetIds",
			Handler:    _ProjectService_TargetIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}

// VagrantfileServiceClient is the client API for VagrantfileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VagrantfileServiceClient interface {
	GetVagrantfile(ctx context.Context, in *Vagrantfile_GetVagrantfileRequest, opts ...grpc.CallOption) (*Vagrantfile_GetVagrantfileResponse, error)
	Target(ctx context.Context, in *Vagrantfile_TargetRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetResponse, error)
	TargetConfig(ctx context.Context, in *Vagrantfile_TargetConfigRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetConfigResponse, error)
	TargetNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Vagrantfile_TargetNamesResponse, error)
	PrimaryTargetName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Vagrantfile_PrimaryTargetNameResponse, error)
}

type vagrantfileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVagrantfileServiceClient(cc grpc.ClientConnInterface) VagrantfileServiceClient {
	return &vagrantfileServiceClient{cc}
}

func (c *vagrantfileServiceClient) GetVagrantfile(ctx context.Context, in *Vagrantfile_GetVagrantfileRequest, opts ...grpc.CallOption) (*Vagrantfile_GetVagrantfileResponse, error) {
	out := new(Vagrantfile_GetVagrantfileResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/GetVagrantfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) Target(ctx context.Context, in *Vagrantfile_TargetRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetResponse, error) {
	out := new(Vagrantfile_TargetResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/Target", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) TargetConfig(ctx context.Context, in *Vagrantfile_TargetConfigRequest, opts ...grpc.CallOption) (*Vagrantfile_TargetConfigResponse, error) {
	out := new(Vagrantfile_TargetConfigResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/TargetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) TargetNames(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Vagrantfile_TargetNamesResponse, error) {
	out := new(Vagrantfile_TargetNamesResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/TargetNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vagrantfileServiceClient) PrimaryTargetName(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Vagrantfile_PrimaryTargetNameResponse, error) {
	out := new(Vagrantfile_PrimaryTargetNameResponse)
	err := c.cc.Invoke(ctx, "/hashicorp.vagrant.sdk.VagrantfileService/PrimaryTargetName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VagrantfileServiceServer is the server API for VagrantfileService service.
// All implementations should embed UnimplementedVagrantfileServiceServer
// for forward compatibility
type VagrantfileServiceServer interface {
	GetVagrantfile(context.Context, *Vagrantfile_GetVagrantfileRequest) (*Vagrantfile_GetVagrantfileResponse, error)
	Target(context.Context, *Vagrantfile_TargetRequest) (*Vagrantfile_TargetResponse, error)
	TargetConfig(context.Context, *Vagrantfile_TargetConfigRequest) (*Vagrantfile_TargetConfigResponse, error)
	TargetNames(context.Context, *empty.Empty) (*Vagrantfile_TargetNamesResponse, error)
	PrimaryTargetName(context.Context, *empty.Empty) (*Vagrantfile_PrimaryTargetNameResponse, error)
}

// UnimplementedVagrantfileServiceServer should be embedded to have forward compatible implementations.
type UnimplementedVagrantfileServiceServer struct {
}

func (UnimplementedVagrantfileServiceServer) GetVagrantfile(context.Context, *Vagrantfile_GetVagrantfileRequest) (*Vagrantfile_GetVagrantfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVagrantfile not implemented")
}
func (UnimplementedVagrantfileServiceServer) Target(context.Context, *Vagrantfile_TargetRequest) (*Vagrantfile_TargetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Target not implemented")
}
func (UnimplementedVagrantfileServiceServer) TargetConfig(context.Context, *Vagrantfile_TargetConfigRequest) (*Vagrantfile_TargetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetConfig not implemented")
}
func (UnimplementedVagrantfileServiceServer) TargetNames(context.Context, *empty.Empty) (*Vagrantfile_TargetNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetNames not implemented")
}
func (UnimplementedVagrantfileServiceServer) PrimaryTargetName(context.Context, *empty.Empty) (*Vagrantfile_PrimaryTargetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrimaryTargetName not implemented")
}

// UnsafeVagrantfileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VagrantfileServiceServer will
// result in compilation errors.
type UnsafeVagrantfileServiceServer interface {
	mustEmbedUnimplementedVagrantfileServiceServer()
}

func RegisterVagrantfileServiceServer(s grpc.ServiceRegistrar, srv VagrantfileServiceServer) {
	s.RegisterService(&_VagrantfileService_serviceDesc, srv)
}

func _VagrantfileService_GetVagrantfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_GetVagrantfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).GetVagrantfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/GetVagrantfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).GetVagrantfile(ctx, req.(*Vagrantfile_GetVagrantfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_Target_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_TargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).Target(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/Target",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).Target(ctx, req.(*Vagrantfile_TargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_TargetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Vagrantfile_TargetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).TargetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/TargetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).TargetConfig(ctx, req.(*Vagrantfile_TargetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_TargetNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).TargetNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/TargetNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).TargetNames(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VagrantfileService_PrimaryTargetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VagrantfileServiceServer).PrimaryTargetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hashicorp.vagrant.sdk.VagrantfileService/PrimaryTargetName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VagrantfileServiceServer).PrimaryTargetName(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _VagrantfileService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hashicorp.vagrant.sdk.VagrantfileService",
	HandlerType: (*VagrantfileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVagrantfile",
			Handler:    _VagrantfileService_GetVagrantfile_Handler,
		},
		{
			MethodName: "Target",
			Handler:    _VagrantfileService_Target_Handler,
		},
		{
			MethodName: "TargetConfig",
			Handler:    _VagrantfileService_TargetConfig_Handler,
		},
		{
			MethodName: "TargetNames",
			Handler:    _VagrantfileService_TargetNames_Handler,
		},
		{
			MethodName: "PrimaryTargetName",
			Handler:    _VagrantfileService_PrimaryTargetName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vagrant_plugin_sdk/plugin.proto",
}
